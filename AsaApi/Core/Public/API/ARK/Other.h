#pragma once
enum class ESocketType
{
	SOCKTYPE_Unknown = 0x0,
	SOCKTYPE_Datagram = 0x1,
	SOCKTYPE_Streaming = 0x2,
};
struct RCONPacket
{
	int Length;
	int Id;
	int Type;
	FString Body;
};
struct FSocket
{
	ESocketType& SocketTypeField() { return *GetNativePointerField<ESocketType*>(this, "FSocket.SocketType"); }
	FString& SocketDescriptionField() { return *GetNativePointerField<FString*>(this, "FSocket.SocketDescription"); }
};
struct RCONClientConnection
{
	FSocket* SocketField() { return *GetNativePointerField<FSocket**>(this, "RCONClientConnection.Socket"); }
	UShooterCheatManager* CheatManagerField() { return *GetNativePointerField<UShooterCheatManager**>(this, "RCONClientConnection.CheatManager"); }
	bool& IsAuthenticatedField() { return *GetNativePointerField<bool*>(this, "RCONClientConnection.IsAuthenticated"); }
	bool& IsClosedField() { return *GetNativePointerField<bool*>(this, "RCONClientConnection.IsClosed"); }
	TArray<signed char>& DataBufferField() { return *GetNativePointerField<TArray<signed char>*>(this, "RCONClientConnection.DataBuffer"); }
	unsigned int& CurrentPacketSizeField() { return *GetNativePointerField<unsigned int*>(this, "RCONClientConnection.CurrentPacketSize"); }
	long double& LastReceiveTimeField() { return *GetNativePointerField<long double*>(this, "RCONClientConnection.LastReceiveTime"); }
	long double& LastSendKeepAliveTimeField() { return *GetNativePointerField<long double*>(this, "RCONClientConnection.LastSendKeepAliveTime"); }
	FString& ServerPasswordField() { return *GetNativePointerField<FString*>(this, "RCONClientConnection.ServerPassword"); }

	// Functions

	void Tick(long double WorldTime, UWorld* InWorld) { NativeCall<void, long double, UWorld*>(this, "RCONClientConnection.Tick(double,UWorld*)", WorldTime, InWorld); }
	void ProcessRCONPacket(RCONPacket* Packet, UWorld* InWorld) { NativeCall<void, RCONPacket*, UWorld*>(this, "RCONClientConnection.ProcessRCONPacket(RCONPacket&,UWorld*)", Packet, InWorld); }
	void SendMessageW(int Id, int Type, FString* OutGoingMessage) { NativeCall<void, int, int, FString*>(this, "RCONClientConnection.SendMessage(int,int,FString&)", Id, Type, OutGoingMessage); }
	void Close() { NativeCall<void>(this, "RCONClientConnection.Close()"); }
};
struct UVictoryCoreHighest : UObject
{
	// Fields


	  // Bitfields


	  // Functions

	static UClass* StaticClass() { return NativeCall<UClass*>(nullptr, "UVictoryCoreHighest.StaticClass()"); }
};

struct UVictoryCore : UVictoryCoreHighest
{
	// Fields


	  // Bitfields


	  // Functions

	static void StaticRegisterNativesUVictoryCore() { NativeCall<void>(nullptr, "UVictoryCore.StaticRegisterNativesUVictoryCore()"); }
	static UClass* GetPrivateStaticClass() { return NativeCall<UClass*>(nullptr, "UVictoryCore.GetPrivateStaticClass()"); }
	static void DestroyWidget(UWidget* WidgetToDestroy) { NativeCall<void, UWidget*>(nullptr, "UVictoryCore.DestroyWidget(UWidget*)", WidgetToDestroy); }
	static int RandInt(int MaxVal) { return NativeCall<int, int>(nullptr, "UVictoryCore.RandInt(int)", MaxVal); }
	static int GetWeightedRandomIndex(const TArray<float, TSizedDefaultAllocator<32> >* pArray, float ForceRand) { return NativeCall<int, const TArray<float, TSizedDefaultAllocator<32> >*, float>(nullptr, "UVictoryCore.GetWeightedRandomIndex(TArray<float,TSizedDefaultAllocator<32>>*,float)", pArray, ForceRand); }
	//static _BOOL8 OverlappingActors() { return NativeCall<_BOOL8>(nullptr, "UVictoryCore.OverlappingActors()"); }
	//static int IsChildOfClassesSoftRefT<class APrimalBuff>(TSubclassOf<UObject> childClass, const //TArray<//TSoftClassPtr<APrimalBuff>, TSizedDefaultAllocator<32> >* ParentClassesArray) { return NativeCall<int, TSubclassOf<UObject>, const //TArray<//TSoftClassPtr<APrimalBuff>, TSizedDefaultAllocator<32> >*>(nullptr, "UVictoryCore.IsChildOfClassesSoftRefT<class APrimalBuff>(TSubclassOf<UObject>,//TArray<//TSoftClassPtr<APrimalBuff>,TSizedDefaultAllocator<32>>*)", childClass, ParentClassesArray); }
	//static int IsChildOfClassesSoftRefT<class APrimalDinoCharacter>(TSubclassOf<UObject> childClass, const //TArray<//TSoftClassPtr<APrimalDinoCharacter>, TSizedDefaultAllocator<32> >* ParentClassesArray) { return NativeCall<int, TSubclassOf<UObject>, const //TArray<//TSoftClassPtr<APrimalDinoCharacter>, TSizedDefaultAllocator<32> >*>(nullptr, "UVictoryCore.IsChildOfClassesSoftRefT<class APrimalDinoCharacter>(TSubclassOf<UObject>,//TArray<//TSoftClassPtr<APrimalDinoCharacter>,TSizedDefaultAllocator<32>>*)", childClass, ParentClassesArray); }
	UShooterGameUserSettings* GetShooterGameUserSettings() { return NativeCall<UShooterGameUserSettings*>(this, "UVictoryCore.GetShooterGameUserSettings()"); }
	static UObjectBase* TracePhysMaterial() { return NativeCall<UObjectBase*>(nullptr, "UVictoryCore.TracePhysMaterial()"); }
	static UObject* GetClassDefaultObject(UClass* FromClass) { return NativeCall<UObject*, UClass*>(nullptr, "UVictoryCore.GetClassDefaultObject(UClass*)", FromClass); }
	static float ClampRotAxis(float BaseAxis, float DesiredAxis, float MaxDiff) { return NativeCall<float, float, float, float>(nullptr, "UVictoryCore.ClampRotAxis(float,float,float)", BaseAxis, DesiredAxis, MaxDiff); }
	static int BPGetWeightedRandomIndex(const TArray<float, TSizedDefaultAllocator<32> >* pArray, float ForceRand) { return NativeCall<int, const TArray<float, TSizedDefaultAllocator<32> >*, float>(nullptr, "UVictoryCore.BPGetWeightedRandomIndex(TArray<float,TSizedDefaultAllocator<32>>*,float)", pArray, ForceRand); }
	static bool ComponentBoundsEncompassesPoint(UPrimitiveComponent* Comp, const UE::Math::TVector<double>* Point, float BoundsMultiplier) { return NativeCall<bool, UPrimitiveComponent*, const UE::Math::TVector<double>*, float>(nullptr, "UVictoryCore.ComponentBoundsEncompassesPoint(UPrimitiveComponent*,UE::Math::TVector<double>*,float)", Comp, Point, BoundsMultiplier); }
	static bool SphereOverlapFast(UObject* WorldContextObject, const UE::Math::TVector<double>* Loc, const float Radius) { return NativeCall<bool, UObject*, const UE::Math::TVector<double>*, const float>(nullptr, "UVictoryCore.SphereOverlapFast(UObject*,UE::Math::TVector<double>*,float)", WorldContextObject, Loc, Radius); }
	//static bool CapsuleOverlapFast(UObject* WorldContextObject, AActor** OutFirstOverlappedActor, const UE::Math::TVector<double>* Origin, const UE::Math::TRotator<double>* CapsuleRotation, float Radius, float HalfHeight, TEnumAsByte<enum ECollisionChannel> CollisionChannel, bool bTraceComplex, bool bIgnoreSelf, AActor* IgnoreActor, bool bDebugDraw, float DebugDrawDuration, bool bBlockingOnly) { return NativeCall<bool, UObject*, AActor**, const UE::Math::TVector<double>*, const UE::Math::TRotator<double>*, float, float, TEnumAsByte<enum ECollisionChannel>, bool, bool, AActor*, bool, float, bool>(nullptr, "UVictoryCore.CapsuleOverlapFast(UObject*,AActor**,UE::Math::TVector<double>*,UE::Math::TRotator<double>*,float,float,TEnumAsByte<enumECollisionChannel>,bool,bool,AActor*,bool,float,bool)", WorldContextObject, OutFirstOverlappedActor, Origin, CapsuleRotation, Radius, HalfHeight, CollisionChannel, bTraceComplex, bIgnoreSelf, IgnoreActor, bDebugDraw, DebugDrawDuration, bBlockingOnly); }
	//static bool CapsuleSweepFast(UObject* WorldContextObject, FHitResult* OutHit, const UE::Math::TVector<double>* Start, const UE::Math::TVector<double>* End, const UE::Math::TRotator<double>* CapsuleRot, float Radius, float HalfHeight, TEnumAsByte<enum ECollisionChannel> CollisionChannel, bool bTraceComplex, bool bIgnoreSelf, const TArray<AActor*, TSizedDefaultAllocator<32> >* IgnoreActors, bool bDebugDraw, float DebugDrawDuration) { return NativeCall<bool, UObject*, FHitResult*, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*, const UE::Math::TRotator<double>*, float, float, TEnumAsByte<enum ECollisionChannel>, bool, bool, const TArray<AActor*, TSizedDefaultAllocator<32> >*, bool, float>(nullptr, "UVictoryCore.CapsuleSweepFast(UObject*,FHitResult*,UE::Math::TVector<double>*,UE::Math::TVector<double>*,UE::Math::TRotator<double>*,float,float,TEnumAsByte<enumECollisionChannel>,bool,bool,TArray<AActor*,TSizedDefaultAllocator<32>>*,bool,float)", WorldContextObject, OutHit, Start, End, CapsuleRot, Radius, HalfHeight, CollisionChannel, bTraceComplex, bIgnoreSelf, IgnoreActors, bDebugDraw, DebugDrawDuration); }
	//static bool CapsuleSweepMulti(UObject* WorldContextObject, TArray<FHitResult, TSizedDefaultAllocator<32> >* OutHits, const UE::Math::TVector<double>* Start, const UE::Math::TVector<double>* End, const UE::Math::TRotator<double>* CapsuleRot, float Radius, float HalfHeight, const TArray<AActor*, TSizedDefaultAllocator<32> >* IgnoreActors, bool bIgnoreSelf, TEnumAsByte<enum ECollisionChannel> CollisionChannel, bool bTraceComplex, bool bDebugDraw, float DebugDrawDuration, bool bFindInitialOverlaps) { return NativeCall<bool, UObject*, TArray<FHitResult, TSizedDefaultAllocator<32> >*, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*, const UE::Math::TRotator<double>*, float, float, const TArray<AActor*, TSizedDefaultAllocator<32> >*, bool, TEnumAsByte<enum ECollisionChannel>, bool, bool, float, bool>(nullptr, "UVictoryCore.CapsuleSweepMulti(UObject*,TArray<FHitResult,TSizedDefaultAllocator<32>>*,UE::Math::TVector<double>*,UE::Math::TVector<double>*,UE::Math::TRotator<double>*,float,float,TArray<AActor*,TSizedDefaultAllocator<32>>*,bool,TEnumAsByte<enumECollisionChannel>,bool,bool,float,bool)", WorldContextObject, OutHits, Start, End, CapsuleRot, Radius, HalfHeight, IgnoreActors, bIgnoreSelf, CollisionChannel, bTraceComplex, bDebugDraw, DebugDrawDuration, bFindInitialOverlaps); }
	//static void MultiTraceProjectSphere(UObject* WorldContextObject, TArray<FHitResult, TSizedDefaultAllocator<32> >* OutResults, const UE::Math::TVector<double>* Origin, ECollisionChannel TraceChannel, int HorizResolution, int VertResolution, float StartDistance, float EndDistance, float NorthConeSubtractAngle, float SouthConeSubtractAngle, int PctChanceToTrace, int MaxTraceCount, bool bDrawDebugLines, float DebugDrawDuration, bool bStopOnFirstHit) { NativeCall<void, UObject*, TArray<FHitResult, TSizedDefaultAllocator<32> >*, const UE::Math::TVector<double>*, ECollisionChannel, int, int, float, float, float, float, int, int, bool, float, bool>(nullptr, "UVictoryCore.MultiTraceProjectSphere(UObject*,TArray<FHitResult,TSizedDefaultAllocator<32>>*,UE::Math::TVector<double>*,ECollisionChannel,int,int,float,float,float,float,int,int,bool,float,bool)", WorldContextObject, OutResults, Origin, TraceChannel, HorizResolution, VertResolution, StartDistance, EndDistance, NorthConeSubtractAngle, SouthConeSubtractAngle, PctChanceToTrace, MaxTraceCount, bDrawDebugLines, DebugDrawDuration, bStopOnFirstHit); }
	static float GetProjectileArcPeakTime(UObject* WorldContextObject, const FProjectileArc* Arc) { return NativeCall<float, UObject*, const FProjectileArc*>(nullptr, "UVictoryCore.GetProjectileArcPeakTime(UObject*,FProjectileArc*)", WorldContextObject, Arc); }
	static void DrawDebugCapsule(UObject* WorldContextObject, const UE::Math::TVector<double>* CapsuleTop, const UE::Math::TVector<double>* CapsuleBottom, float Radius, const FColor* Color, bool bPersistentLines, float LifeTime, unsigned __int8 DepthPriority) { NativeCall<void, UObject*, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*, float, const FColor*, bool, float, unsigned __int8>(nullptr, "UVictoryCore.DrawDebugCapsule(UObject*,UE::Math::TVector<double>*,UE::Math::TVector<double>*,float,FColor*,bool,float,unsigned__int8)", WorldContextObject, CapsuleTop, CapsuleBottom, Radius, Color, bPersistentLines, LifeTime, DepthPriority); }
	//static bool TraceProjectileArc(UObject* WorldContextObject, const FProjectileArc* Arc, FHitResult* OutHitResult, UE::Math::TVector<double>* OutEndLocation, float* OutEndArcTime, UE::Math::TVector<double>* OutArcPeakLocation, float MaxArcLength, const TArray<AActor*, TSizedDefaultAllocator<32> >* ActorsToIgnore, float ArcTimeStep, ECollisionChannel CollisionChannel, bool bTraceObjectTypeOnly, bool bDrawDebug, float DebugDrawDuration) { return NativeCall<bool, UObject*, const FProjectileArc*, FHitResult*, UE::Math::TVector<double>*, float*, UE::Math::TVector<double>*, float, const TArray<AActor*, TSizedDefaultAllocator<32> >*, float, ECollisionChannel, bool, bool, float>(nullptr, "UVictoryCore.TraceProjectileArc(UObject*,FProjectileArc*,FHitResult*,UE::Math::TVector<double>*,float*,UE::Math::TVector<double>*,float,TArray<AActor*,TSizedDefaultAllocator<32>>*,float,ECollisionChannel,bool,bool,float)", WorldContextObject, Arc, OutHitResult, OutEndLocation, OutEndArcTime, OutArcPeakLocation, MaxArcLength, ActorsToIgnore, ArcTimeStep, CollisionChannel, bTraceObjectTypeOnly, bDrawDebug, DebugDrawDuration); }
	//static bool CapsuleSweepProjectileArc(UObject* WorldContextObject, const FProjectileArc* Arc, const UE::Math::TRotator<double>* CapsuleRotation, float CapsuleRadius, float CapsuleHalfHeight, bool bRotateCapsuleAlongPath, bool bTraceComplex, FHitResult* OutHitResult, UE::Math::TVector<double>* OutEndLocation, float* OutEndArcTime, float MaxArcLength, const TArray<AActor*, TSizedDefaultAllocator<32> >* ActorsToIgnore, bool bIgnoreSelf, float ArcTimeStep, TEnumAsByte<enum ECollisionChannel> CollisionChannel, bool bDrawDebug, float DebugDrawDuration) { return NativeCall<bool, UObject*, const FProjectileArc*, const UE::Math::TRotator<double>*, float, float, bool, bool, FHitResult*, UE::Math::TVector<double>*, float*, float, const TArray<AActor*, TSizedDefaultAllocator<32> >*, bool, float, TEnumAsByte<enum ECollisionChannel>, bool, float>(nullptr, "UVictoryCore.CapsuleSweepProjectileArc(UObject*,FProjectileArc*,UE::Math::TRotator<double>*,float,float,bool,bool,FHitResult*,UE::Math::TVector<double>*,float*,float,TArray<AActor*,TSizedDefaultAllocator<32>>*,bool,float,TEnumAsByte<enumECollisionChannel>,bool,float)", WorldContextObject, Arc, CapsuleRotation, CapsuleRadius, CapsuleHalfHeight, bRotateCapsuleAlongPath, bTraceComplex, OutHitResult, OutEndLocation, OutEndArcTime, MaxArcLength, ActorsToIgnore, bIgnoreSelf, ArcTimeStep, CollisionChannel, bDrawDebug, DebugDrawDuration); }
	//static void MultiLinePenetrationTraceByChannel(UObject* WorldContextObject, TArray<FPenetrationTraceHit, TSizedDefaultAllocator<32> >* OutResults, const UE::Math::TVector<double>* Start, const UE::Math::TVector<double>* End, ECollisionChannel TraceChannel, const TArray<AActor*, TSizedDefaultAllocator<32> >* ActorsToIgnore, bool bTraceComplex, bool bIgnoreSelf, bool bDrawDebugLines, float DebugDrawDuration) { NativeCall<void, UObject*, TArray<FPenetrationTraceHit, TSizedDefaultAllocator<32> >*, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*, ECollisionChannel, const TArray<AActor*, TSizedDefaultAllocator<32> >*, bool, bool, bool, float>(nullptr, "UVictoryCore.MultiLinePenetrationTraceByChannel(UObject*,TArray<FPenetrationTraceHit,TSizedDefaultAllocator<32>>*,UE::Math::TVector<double>*,UE::Math::TVector<double>*,ECollisionChannel,TArray<AActor*,TSizedDefaultAllocator<32>>*,bool,bool,bool,float)", WorldContextObject, OutResults, Start, End, TraceChannel, ActorsToIgnore, bTraceComplex, bIgnoreSelf, bDrawDebugLines, DebugDrawDuration); }
	static bool FindValidLocationNextToTarget(UObject* WorldContextObject, UE::Math::TVector<double>* OutLocation, APrimalCharacter* SourceCharacter, APrimalCharacter* TargetCharacter, float DistanceMargin, int MaxTraceCount, AActor* ActorToIgnore, bool bTraceComplex, bool bDrawDebug, float DebugDrawDuration, bool AllowCloseDistance, bool AllowLocationInAir) { return NativeCall<bool, UObject*, UE::Math::TVector<double>*, APrimalCharacter*, APrimalCharacter*, float, int, AActor*, bool, bool, float, bool, bool>(nullptr, "UVictoryCore.FindValidLocationNextToTarget(UObject*,UE::Math::TVector<double>*,APrimalCharacter*,APrimalCharacter*,float,int,AActor*,bool,bool,float,bool,bool)", WorldContextObject, OutLocation, SourceCharacter, TargetCharacter, DistanceMargin, MaxTraceCount, ActorToIgnore, bTraceComplex, bDrawDebug, DebugDrawDuration, AllowCloseDistance, AllowLocationInAir); }
	//	static bool FindValidLocationInFrontOfTarget(UE::Math::TVector<double>* OutLocation, APrimalCharacter* SourceCharacter, APrimalCharacter* TargetCharacter, float DistanceMargin, TEnumAsByte<enum ECollisionChannel> CollisionChannel, bool bFailIfLocationNotOnGround, AActor* ActorToIgnore, bool bTraceComplex, float DebugDrawDuration) { return NativeCall<bool, UE::Math::TVector<double>*, APrimalCharacter*, APrimalCharacter*, float, TEnumAsByte<enum ECollisionChannel>, bool, AActor*, bool, float>(nullptr, "UVictoryCore.FindValidLocationInFrontOfTarget(UE::Math::TVector<double>*,APrimalCharacter*,APrimalCharacter*,float,TEnumAsByte<enumECollisionChannel>,bool,AActor*,bool,float)", OutLocation, SourceCharacter, TargetCharacter, DistanceMargin, CollisionChannel, bFailIfLocationNotOnGround, ActorToIgnore, bTraceComplex, DebugDrawDuration); }
	static void GridTraceAroundPoint() { NativeCall<void>(nullptr, "UVictoryCore.GridTraceAroundPoint()"); }
	//static float SimpleCurveEval(float Value, TEnumAsByte<enum ESimpleCurve::Type> CurveType) { return NativeCall<float, float, TEnumAsByte<enum ESimpleCurve::Type>>(nullptr, "UVictoryCore.SimpleCurveEval(float,TEnumAsByte<enumESimpleCurve::Type>)", Value, CurveType); }
	//static float SimpleCurveInterpClamped(float A, float B, float Alpha, TEnumAsByte<enum ESimpleCurve::Type> CurveType) { return NativeCall<float, float, float, float, TEnumAsByte<enum ESimpleCurve::Type>>(nullptr, "UVictoryCore.SimpleCurveInterpClamped(float,float,float,TEnumAsByte<enumESimpleCurve::Type>)", A, B, Alpha, CurveType); }
	//static float MapRangeToCurveClamped(float Value, float InRangeA, float InRangeB, float OutRangeA, float OutRangeB, TEnumAsByte<enum ESimpleCurve::Type> CurveType) { return NativeCall<float, float, float, float, float, float, TEnumAsByte<enum ESimpleCurve::Type>>(nullptr, "UVictoryCore.MapRangeToCurveClamped(float,float,float,float,float,TEnumAsByte<enumESimpleCurve::Type>)", Value, InRangeA, InRangeB, OutRangeA, OutRangeB, CurveType); }
	//static float MapAngleRangeToCurveClamped(float AngleDegrees, float InRangeA, float InRangeB, float OutRangeA, float OutRangeB, TEnumAsByte<enum ESimpleCurve::Type> CurveType) { return NativeCall<float, float, float, float, float, float, TEnumAsByte<enum ESimpleCurve::Type>>(nullptr, "UVictoryCore.MapAngleRangeToCurveClamped(float,float,float,float,float,TEnumAsByte<enumESimpleCurve::Type>)", AngleDegrees, InRangeA, InRangeB, OutRangeA, OutRangeB, CurveType); }
	static bool BPFastTrace() { return NativeCall<bool>(nullptr, "UVictoryCore.BPFastTrace()"); }
	//static bool SplineLineTrace(USplineComponent* SplineComponent, const TArray<AActor*, TSizedDefaultAllocator<32> >* ActorsToIgnore, TArray<FHitResult, TSizedDefaultAllocator<32> >* OutHits, int NumTracesPerSegment, ECollisionChannel Channel, bool bStopOnBlockingHit, float DebugDrawDuration) { return NativeCall<bool, USplineComponent*, const TArray<AActor*, TSizedDefaultAllocator<32> >*, TArray<FHitResult, TSizedDefaultAllocator<32> >*, int, ECollisionChannel, bool, float>(nullptr, "UVictoryCore.SplineLineTrace(USplineComponent*,TArray<AActor*,TSizedDefaultAllocator<32>>*,TArray<FHitResult,TSizedDefaultAllocator<32>>*,int,ECollisionChannel,bool,float)", SplineComponent, ActorsToIgnore, OutHits, NumTracesPerSegment, Channel, bStopOnBlockingHit, DebugDrawDuration); }
	//static bool VTraceIgnoreFoliage(UWorld* theWorld, const UE::Math::TVector<double>* Start, const UE::Math::TVector<double>* End, FHitResult* HitOut, const AActor* ActorToIgnore, ECollisionChannel Channel, int CollisionGroups, bool bReturnPhysMaterial, bool bTraceComplex, const UE::Math::TVector<double>* BoxExtent, FName TraceTag, const AActor* OtherActorToIgnore, TArray<AActor*, TSizedDefaultAllocator<32> >* OtherActorsToIgnore, const UE::Math::TQuat<double>* Rot, const AActor* AnotherActorToIgnore, bool bIgnoreFoliage) { return NativeCall<bool, UWorld*, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*, FHitResult*, const AActor*, ECollisionChannel, int, bool, bool, const UE::Math::TVector<double>*, FName, const AActor*, TArray<AActor*, TSizedDefaultAllocator<32> >*, const UE::Math::TQuat<double>*, const AActor*, bool>(nullptr, "UVictoryCore.VTraceIgnoreFoliage(UWorld*,UE::Math::TVector<double>*,UE::Math::TVector<double>*,FHitResult*,AActor*,ECollisionChannel,int,bool,bool,UE::Math::TVector<double>*,FName,AActor*,TArray<AActor*,TSizedDefaultAllocator<32>>*,UE::Math::TQuat<double>*,AActor*,bool)", theWorld, Start, End, HitOut, ActorToIgnore, Channel, CollisionGroups, bReturnPhysMaterial, bTraceComplex, BoxExtent, TraceTag, OtherActorToIgnore, OtherActorsToIgnore, Rot, AnotherActorToIgnore, bIgnoreFoliage); }
	static void SetSessionPrefix(const FString* InPrefix) { NativeCall<void, const FString*>(nullptr, "UVictoryCore.SetSessionPrefix(FString&)", InPrefix); }
	static FColor* GetTeamColor(FColor* result, const int TargetingTeam) { return NativeCall<FColor*, FColor*, const int>(nullptr, "UVictoryCore.GetTeamColor(FColor*,int)", result, TargetingTeam); }
	static FString* FormatAsTime(FString* result, int InTime, bool UseLeadingZero, bool bForceLeadingZeroHour, bool bShowSeconds) { return NativeCall<FString*, FString*, int, bool, bool, bool>(nullptr, "UVictoryCore.FormatAsTime(FString&,int,bool,bool,bool)", result, InTime, UseLeadingZero, bForceLeadingZeroHour, bShowSeconds); }
	static FString* FormatAsTimeLong(FString* result, int InTime) { return NativeCall<FString*, FString*, int>(nullptr, "UVictoryCore.FormatAsTimeLong(FString&,int)", result, InTime); }
	static bool CalculateInterceptPosition(const UE::Math::TVector<double>* StartPosition, const UE::Math::TVector<double>* StartVelocity, float ProjectileVelocity, const UE::Math::TVector<double>* TargetPosition, const UE::Math::TVector<double>* TargetVelocity, UE::Math::TVector<double>* InterceptPosition) { return NativeCall<bool, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*, float, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*, UE::Math::TVector<double>*>(nullptr, "UVictoryCore.CalculateInterceptPosition(UE::Math::TVector<double>*,UE::Math::TVector<double>*,float,UE::Math::TVector<double>*,UE::Math::TVector<double>*,UE::Math::TVector<double>*)", StartPosition, StartVelocity, ProjectileVelocity, TargetPosition, TargetVelocity, InterceptPosition); }
	static int GetSecondsIntoDay() { return NativeCall<int>(nullptr, "UVictoryCore.GetSecondsIntoDay()"); }
	static bool GetGroundLocation(UObject* WorldContextObject, UE::Math::TVector<double>* theGroundLoc, const UE::Math::TVector<double>* StartLoc, const UE::Math::TVector<double>* OffsetUp, const UE::Math::TVector<double>* OffsetDown) { return NativeCall<bool, UObject*, UE::Math::TVector<double>*, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*>(nullptr, "UVictoryCore.GetGroundLocation(UObject*,UE::Math::TVector<double>*,UE::Math::TVector<double>*,UE::Math::TVector<double>*,UE::Math::TVector<double>*)", WorldContextObject, theGroundLoc, StartLoc, OffsetUp, OffsetDown); }
	static void CallGlobalLevelEvent(UObject* WorldContextObject, FName EventName) { NativeCall<void, UObject*, FName>(nullptr, "UVictoryCore.CallGlobalLevelEvent(UObject*,FName)", WorldContextObject, EventName); }
	static void StopAllMusicTracks(const UObject* WorldContextObject) { NativeCall<void, const UObject*>(nullptr, "UVictoryCore.StopAllMusicTracks(UObject*)", WorldContextObject); }
	static TArray<AActor*>* ServerOctreeOverlapActors(TArray<AActor*, TSizedDefaultAllocator<32> >* result, UObject* WorldContextObject, UE::Math::TVector<double>* AtLoc, float Radius, int OctreeType, bool bForceActorLocationDistanceCheck) { return NativeCall<TArray<AActor*>*, TArray<AActor*>*, UObject*, UE::Math::TVector<double>*, float, int, bool>(nullptr, "UVictoryCore.ServerOctreeOverlapActors(UObject*,UE::Math::TVector<double>,float,EServerOctreeGroup::Type,bool)", result, WorldContextObject, AtLoc, Radius, OctreeType, bForceActorLocationDistanceCheck); }
	static TArray<AActor*>* ServerOctreeOverlapActorsClass(TArray<AActor*, TSizedDefaultAllocator<32> >* result, UObject* WorldContextObject, UE::Math::TVector<double>* AtLoc, float Radius, int OctreeType, TSubclassOf<AActor> ActorClass, bool bForceActorLocationDistanceCheck) { return NativeCall<TArray<AActor*>*, TArray<AActor*>*, UObject*, UE::Math::TVector<double>*, float, int, TSubclassOf<AActor>, bool>(nullptr, "UVictoryCore.ServerOctreeOverlapActors(UObject*,UE::Math::TVector<double>,float,EServerOctreeGroup::Type,bool)", result, WorldContextObject, AtLoc, Radius, OctreeType, ActorClass, bForceActorLocationDistanceCheck); }
	static bool IsVerboseDisplayEnabled(const UObject* WorldContextObject) { return NativeCall<bool, const UObject*>(nullptr, "UVictoryCore.IsVerboseDisplayEnabled(UObject*)", WorldContextObject); }
	static AActor* SpawnActorDeferred(UClass* Class, UObject* WorldContextObject, const UE::Math::TVector<double>* Location, const UE::Math::TRotator<double>* Rotation, AActor* Owner, APawn* Instigator, bool bNoCollisionFail) { return NativeCall<AActor*, UClass*, UObject*, const UE::Math::TVector<double>*, const UE::Math::TRotator<double>*, AActor*, APawn*, bool>(nullptr, "UVictoryCore.SpawnActorDeferred(UClass*,UObject*,UE::Math::TVector<double>*,UE::Math::TRotator<double>*,AActor*,APawn*,bool)", Class, WorldContextObject, Location, Rotation, Owner, Instigator, bNoCollisionFail); }
	static void FinishSpawning(AActor* Actor) { NativeCall<void, AActor*>(nullptr, "UVictoryCore.FinishSpawning(AActor*)", Actor); }
	static bool KillTargetCharacterOrStructure(AActor* ActorToKill, AActor* DamageCauser, bool bTryDestroyActor) { return NativeCall<bool, AActor*, AActor*, bool>(nullptr, "UVictoryCore.KillTargetCharacterOrStructure(AActor*,AActor*,bool)", ActorToKill, DamageCauser, bTryDestroyActor); }
	static __int64 GetWeightedRandomIndexFromArray() { return NativeCall<__int64>(nullptr, "UVictoryCore.GetWeightedRandomIndexFromArray()"); }
	static AActor* GetClosestActorArray() { return NativeCall<AActor*>(nullptr, "UVictoryCore.GetClosestActorArray()"); }
	//static void GetSpecialActorList(UObject* WorldContextObject, TEnumAsByte<enum EActorListsBP::Type> ActorListType, TArray<AActor*, TSizedDefaultAllocator<32> >* OutActors) { NativeCall<void, UObject*, TEnumAsByte<enum EActorListsBP::Type>, TArray<AActor*, TSizedDefaultAllocator<32> >*>(nullptr, "UVictoryCore.GetSpecialActorList(UObject*,TEnumAsByte<enumEActorListsBP::Type>,TArray<AActor*,TSizedDefaultAllocator<32>>*)", WorldContextObject, ActorListType, OutActors); }
	static ACustomActorList* GetCustomActorList(UObject* WorldContextObject, FName SearchCustomTag) { return NativeCall<ACustomActorList*, UObject*, FName>(nullptr, "UVictoryCore.GetCustomActorList(UObject*,FName)", WorldContextObject, SearchCustomTag); }
	static long double GetNetworkTimeInSeconds(UObject* WorldContextObject) { return NativeCall<long double, UObject*>(nullptr, "UVictoryCore.GetNetworkTimeInSeconds(UObject*)", WorldContextObject); }
	static long double GetRealWorldUtcTimeInSeconds() { return NativeCall<long double>(nullptr, "UVictoryCore.GetRealWorldUtcTimeInSeconds()"); }
	static long double NetworkTimeToRealWorldUtcTime(UObject* WorldContextObject, long double NetworkTime) { return NativeCall<long double, UObject*, long double>(nullptr, "UVictoryCore.NetworkTimeToRealWorldUtcTime(UObject*,longdouble)", WorldContextObject, NetworkTime); }
	static TArray<APlayerCameraManager*, TSizedDefaultAllocator<32> >* GetAllLocalPlayerCameraManagers(TArray<APlayerCameraManager*, TSizedDefaultAllocator<32> >* result, UObject* WorldContextObject) { return NativeCall<TArray<APlayerCameraManager*, TSizedDefaultAllocator<32> >*, TArray<APlayerCameraManager*, TSizedDefaultAllocator<32> >*, UObject*>(nullptr, "UVictoryCore.GetAllLocalPlayerCameraManagers(TArray<APlayerCameraManager*,TSizedDefaultAllocator<32>>*,UObject*)", result, WorldContextObject); }
	static AShooterCharacter* GetShooterCharacterFromPawn(APawn* Pawn) { return NativeCall<AShooterCharacter*, APawn*>(nullptr, "UVictoryCore.GetShooterCharacterFromPawn(APawn*)", Pawn); }
	static AShooterCharacter* GetShooterCharacterFromController(AController* Controller) { return NativeCall<AShooterCharacter*, AController*>(nullptr, "UVictoryCore.GetShooterCharacterFromController(AController*)", Controller); }
	//static bool VTraceSingleBP(UObject* WorldContextObject, FHitResult* OutHit, const UE::Math::TVector<double>* Start, const UE::Math::TVector<double>* End, ECollisionChannel TraceChannel, int CollisionGroups, FName TraceTag, bool bTraceComplex, AActor* ActorToIgnore, float DebugDrawDuration) { return NativeCall<bool, UObject*, FHitResult*, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*, ECollisionChannel, int, FName, bool, AActor*, float>(nullptr, "UVictoryCore.VTraceSingleBP(UObject*,FHitResult*,UE::Math::TVector<double>*,UE::Math::TVector<double>*,ECollisionChannel,int,FName,bool,AActor*,float)", WorldContextObject, OutHit, Start, End, TraceChannel, CollisionGroups, TraceTag, bTraceComplex, ActorToIgnore, DebugDrawDuration); }
	//static bool VTraceSingleBP_IgnoreActorsArray(UObject* WorldContextObject, FHitResult* OutHit, const UE::Math::TVector<double>* Start, const UE::Math::TVector<double>* End, const TArray<AActor*, TSizedDefaultAllocator<32> >* ExtraIgnoreActors, const AActor* InIgnoreActor, ECollisionChannel TraceChannel, int CollisionGroups, FName TraceTag, bool bReturnPhysMaterial, bool bTraceComplex, float DebugDrawDuration) { return NativeCall<bool, UObject*, FHitResult*, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*, const TArray<AActor*, TSizedDefaultAllocator<32> >*, const AActor*, ECollisionChannel, int, FName, bool, bool, float>(nullptr, "UVictoryCore.VTraceSingleBP_IgnoreActorsArray(UObject*,FHitResult*,UE::Math::TVector<double>*,UE::Math::TVector<double>*,TArray<AActor*,TSizedDefaultAllocator<32>>*,AActor*,ECollisionChannel,int,FName,bool,bool,float)", WorldContextObject, OutHit, Start, End, ExtraIgnoreActors, InIgnoreActor, TraceChannel, CollisionGroups, TraceTag, bReturnPhysMaterial, bTraceComplex, DebugDrawDuration); }
	//static bool VTraceSphereBP(UObject* WorldContextObject, const UE::Math::TVector<double>* Start, const UE::Math::TVector<double>* End, FHitResult* HitOut, float Radius, const AActor* ActorToIgnore, ECollisionChannel Channel, int CollisionGroups, bool bReturnPhysMaterial, bool bTraceComplex, FName TraceTag, const AActor* OtherActorToIgnore, AActor* AnotherActorToIgnore, float DebugDrawDuration) { return NativeCall<bool, UObject*, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*, FHitResult*, float, const AActor*, ECollisionChannel, int, bool, bool, FName, const AActor*, AActor*, float>(nullptr, "UVictoryCore.VTraceSphereBP(UObject*,UE::Math::TVector<double>*,UE::Math::TVector<double>*,FHitResult*,float,AActor*,ECollisionChannel,int,bool,bool,FName,AActor*,AActor*,float)", WorldContextObject, Start, End, HitOut, Radius, ActorToIgnore, Channel, CollisionGroups, bReturnPhysMaterial, bTraceComplex, TraceTag, OtherActorToIgnore, AnotherActorToIgnore, DebugDrawDuration); }
	//static bool VTraceSphereBP_IgnoreActorsArray(UObject* WorldContextObject, const UE::Math::TVector<double>* Start, const UE::Math::TVector<double>* End, FHitResult* HitOut, float Radius, const TArray<AActor*, TSizedDefaultAllocator<32> >* ExtraIgnoreActors, const AActor* InIgnoreActor, ECollisionChannel Channel, int CollisionGroups, bool bReturnPhysMaterial, bool bTraceComplex, FName TraceTag, float DebugDrawDuration) { return NativeCall<bool, UObject*, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*, FHitResult*, float, const TArray<AActor*, TSizedDefaultAllocator<32> >*, const AActor*, ECollisionChannel, int, bool, bool, FName, float>(nullptr, "UVictoryCore.VTraceSphereBP_IgnoreActorsArray(UObject*,UE::Math::TVector<double>*,UE::Math::TVector<double>*,FHitResult*,float,TArray<AActor*,TSizedDefaultAllocator<32>>*,AActor*,ECollisionChannel,int,bool,bool,FName,float)", WorldContextObject, Start, End, HitOut, Radius, ExtraIgnoreActors, InIgnoreActor, Channel, CollisionGroups, bReturnPhysMaterial, bTraceComplex, TraceTag, DebugDrawDuration); }
	static bool VTraceShapeBP() { return NativeCall<bool>(nullptr, "UVictoryCore.VTraceShapeBP()"); }
	static bool VTraceShapeMultiBP() { return NativeCall<bool>(nullptr, "UVictoryCore.VTraceShapeMultiBP()"); }
	//static bool VTraceMulti(UWorld* theWorld, TArray<FHitResult, TSizedDefaultAllocator<32> >* OutHits, const UE::Math::TVector<double>* Start, const UE::Math::TVector<double>* End, AActor* InIgnoreActor, int CollisionGroups, float SphereRadius, const UE::Math::TVector<double>* BoxExtent, bool bReturnPhysMaterial, ECollisionChannel TraceChannel, bool bTraceComplex, FName TraceTag, bool bTraceChannelForceOverlap, bool bDoSort, AActor* AdditionalIgnoreActor, AActor* AnotherIgnoreActor, bool bJustDoSphereOverlapAtStartLoc, TArray<AActor*, TSizedDefaultAllocator<32> >* ExtraIgnoreActors) { return NativeCall<bool, UWorld*, TArray<FHitResult, TSizedDefaultAllocator<32> >*, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*, AActor*, int, float, const UE::Math::TVector<double>*, bool, ECollisionChannel, bool, FName, bool, bool, AActor*, AActor*, bool, TArray<AActor*, TSizedDefaultAllocator<32> >*>(nullptr, "UVictoryCore.VTraceMulti(UWorld*,TArray<FHitResult,TSizedDefaultAllocator<32>>*,UE::Math::TVector<double>*,UE::Math::TVector<double>*,AActor*,int,float,UE::Math::TVector<double>*,bool,ECollisionChannel,bool,FName,bool,bool,AActor*,AActor*,bool,TArray<AActor*,TSizedDefaultAllocator<32>>*)", theWorld, OutHits, Start, End, InIgnoreActor, CollisionGroups, SphereRadius, BoxExtent, bReturnPhysMaterial, TraceChannel, bTraceComplex, TraceTag, bTraceChannelForceOverlap, bDoSort, AdditionalIgnoreActor, AnotherIgnoreActor, bJustDoSphereOverlapAtStartLoc, ExtraIgnoreActors); }
	//static bool VTraceMultiBP(UObject* WorldContextObject, TArray<FHitResult, TSizedDefaultAllocator<32> >* OutHits, const UE::Math::TVector<double>* Start, const UE::Math::TVector<double>* End, AActor* InIgnoreActor, int CollisionGroups, float SphereRadius, const UE::Math::TVector<double>* BoxExtent, bool bReturnPhysMaterial, ECollisionChannel TraceChannel, bool bTraceComplex, FName TraceTag, bool bTraceChannelForceOverlap, bool bDoSort, AActor* AdditionalIgnoreActor, AActor* AnotherIgnoreActor, bool bJustDoSphereOverlapAtStartLoc, float DebugDrawDuration) { return NativeCall<bool, UObject*, TArray<FHitResult, TSizedDefaultAllocator<32> >*, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*, AActor*, int, float, const UE::Math::TVector<double>*, bool, ECollisionChannel, bool, FName, bool, bool, AActor*, AActor*, bool, float>(nullptr, "UVictoryCore.VTraceMultiBP(UObject*,TArray<FHitResult,TSizedDefaultAllocator<32>>*,UE::Math::TVector<double>*,UE::Math::TVector<double>*,AActor*,int,float,UE::Math::TVector<double>*,bool,ECollisionChannel,bool,FName,bool,bool,AActor*,AActor*,bool,float)", WorldContextObject, OutHits, Start, End, InIgnoreActor, CollisionGroups, SphereRadius, BoxExtent, bReturnPhysMaterial, TraceChannel, bTraceComplex, TraceTag, bTraceChannelForceOverlap, bDoSort, AdditionalIgnoreActor, AnotherIgnoreActor, bJustDoSphereOverlapAtStartLoc, DebugDrawDuration); }
	//static bool VTraceMultiBP_IgnoreActorsArray(UObject* WorldContextObject, TArray<FHitResult, TSizedDefaultAllocator<32> >* OutHits, const UE::Math::TVector<double>* Start, const UE::Math::TVector<double>* End, const TArray<AActor*, TSizedDefaultAllocator<32> >* ExtraIgnoreActors, AActor* InIgnoreActor, int CollisionGroups, float SphereRadius, const UE::Math::TVector<double>* BoxExtent, bool bReturnPhysMaterial, ECollisionChannel TraceChannel, bool bTraceComplex, FName TraceTag, bool bTraceChannelForceOverlap, bool bDoSort, bool bJustDoSphereOverlapAtStartLoc, float DebugDrawDuration) { return NativeCall<bool, UObject*, TArray<FHitResult, TSizedDefaultAllocator<32> >*, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*, const TArray<AActor*, TSizedDefaultAllocator<32> >*, AActor*, int, float, const UE::Math::TVector<double>*, bool, ECollisionChannel, bool, FName, bool, bool, bool, float>(nullptr, "UVictoryCore.VTraceMultiBP_IgnoreActorsArray(UObject*,TArray<FHitResult,TSizedDefaultAllocator<32>>*,UE::Math::TVector<double>*,UE::Math::TVector<double>*,TArray<AActor*,TSizedDefaultAllocator<32>>*,AActor*,int,float,UE::Math::TVector<double>*,bool,ECollisionChannel,bool,FName,bool,bool,bool,float)", WorldContextObject, OutHits, Start, End, ExtraIgnoreActors, InIgnoreActor, CollisionGroups, SphereRadius, BoxExtent, bReturnPhysMaterial, TraceChannel, bTraceComplex, TraceTag, bTraceChannelForceOverlap, bDoSort, bJustDoSphereOverlapAtStartLoc, DebugDrawDuration); }
	static bool IsGamePadConnected() { return NativeCall<bool>(nullptr, "UVictoryCore.IsGamePadConnected()"); }
	//static int IsChildOfClasses(TSubclassOf<UObject> childClass, const //TArray<TSubclassOf<UObject>, TSizedDefaultAllocator<32> >* ParentClassesArray) { return NativeCall<int, TSubclassOf<UObject>, const //TArray<TSubclassOf<UObject>, TSizedDefaultAllocator<32> >*>(nullptr, "UVictoryCore.IsChildOfClasses(TSubclassOf<UObject>,//TArray<TSubclassOf<UObject>,TSizedDefaultAllocator<32>>*)", childClass, ParentClassesArray); }
	static bool ObjectIsChildOfSoftRef() { return NativeCall<bool>(nullptr, "UVictoryCore.ObjectIsChildOfSoftRef()"); }
	static bool IsPVEServer(UObject* WorldContextObject) { return NativeCall<bool, UObject*>(nullptr, "UVictoryCore.IsPVEServer(UObject*)", WorldContextObject); }
	static bool IsTimeSince_Network(UObject* WorldContextObject, long double OldTime, float CheckTimeSince, bool bForceTrueAtZeroTime) { return NativeCall<bool, UObject*, long double, float, bool>(nullptr, "UVictoryCore.IsTimeSince_Network(UObject*,longdouble,float,bool)", WorldContextObject, OldTime, CheckTimeSince, bForceTrueAtZeroTime); }
	static bool IsTimeSince_Utc(long double OldTime, float CheckTimeSince, bool bForceTrueAtZeroTime) { return NativeCall<bool, long double, float, bool>(nullptr, "UVictoryCore.IsTimeSince_Utc(longdouble,float,bool)", OldTime, CheckTimeSince, bForceTrueAtZeroTime); }
	static float TimeSince_Network(UObject* WorldContextObject, long double OldTime) { return NativeCall<float, UObject*, long double>(nullptr, "UVictoryCore.TimeSince_Network(UObject*,longdouble)", WorldContextObject, OldTime); }
	static bool IsTimeSince(UObject* WorldContextObject, long double OldTime, float CheckTimeSince, bool bForceTrueAtZeroTime) { return NativeCall<bool, UObject*, long double, float, bool>(nullptr, "UVictoryCore.IsTimeSince(UObject*,longdouble,float,bool)", WorldContextObject, OldTime, CheckTimeSince, bForceTrueAtZeroTime); }
	static float TimeSince(UObject* WorldContextObject, long double OldTime) { return NativeCall<float, UObject*, long double>(nullptr, "UVictoryCore.TimeSince(UObject*,longdouble)", WorldContextObject, OldTime); }
	//static FString* LeaderboardColumnNameToString(FString* result, TEnumAsByte<enum ELeaderboardColumnName::Type> ColumnType) { return NativeCall<FString*, FString*, TEnumAsByte<enum ELeaderboardColumnName::Type>>(nullptr, "UVictoryCore.LeaderboardColumnNameToString(FString&,TEnumAsByte<enumELeaderboardColumnName::Type>)", result, ColumnType); }
	static void PauseTimer() { NativeCall<void>(nullptr, "UVictoryCore.PauseTimer()"); }
	static void UnPauseTimer() { NativeCall<void>(nullptr, "UVictoryCore.UnPauseTimer()"); }
	static bool IsTimerActive() { return NativeCall<bool>(nullptr, "UVictoryCore.IsTimerActive()"); }
	static bool IsTimerPaused() { return NativeCall<bool>(nullptr, "UVictoryCore.IsTimerPaused()"); }
	static FString* GetLastMapPlayed(FString* result) { return NativeCall<FString*, FString*>(nullptr, "UVictoryCore.GetLastMapPlayed(FString&)", result); }
	static void SetLastMapPlayed(const FString* NewLastMapPlayed) { NativeCall<void, const FString*>(nullptr, "UVictoryCore.SetLastMapPlayed(FString&)", NewLastMapPlayed); }
	static FString* GetLastHostedMapPlayed(FString* result) { return NativeCall<FString*, FString*>(nullptr, "UVictoryCore.GetLastHostedMapPlayed(FString&)", result); }
	static void SetLastHostedMapPlayed(const FString* NewLastHostedMapPlayed) { NativeCall<void, const FString*>(nullptr, "UVictoryCore.SetLastHostedMapPlayed(FString&)", NewLastHostedMapPlayed); }
	static bool OwnsScorchedEarth() { return NativeCall<bool>(nullptr, "UVictoryCore.OwnsScorchedEarth()"); }
	static bool OwnsAberration() { return NativeCall<bool>(nullptr, "UVictoryCore.OwnsAberration()"); }
	static bool OwnsExtinction() { return NativeCall<bool>(nullptr, "UVictoryCore.OwnsExtinction()"); }
	static bool OwnsGenesisSeasonPass() { return NativeCall<bool>(nullptr, "UVictoryCore.OwnsGenesisSeasonPass()"); }
	static bool OwnsGenesis() { return NativeCall<bool>(nullptr, "UVictoryCore.OwnsGenesis()"); }
	static bool IsEngramGroupAllowed(AShooterPlayerController* forPC, int EngramGroup) { return NativeCall<bool, AShooterPlayerController*, int>(nullptr, "UVictoryCore.IsEngramGroupAllowed(AShooterPlayerController*,int)", forPC, EngramGroup); }
	static bool DoesOwnSelectedDLC(EDLCSelector SelectedDLC) { return NativeCall<bool, EDLCSelector>(nullptr, "UVictoryCore.DoesOwnSelectedDLC(EDLCSelector)", SelectedDLC); }
	static FString* GetDLCNameFromSelector(FString* result, EDLCSelector SelectedDLC) { return NativeCall<FString*, FString*, EDLCSelector>(nullptr, "UVictoryCore.GetDLCNameFromSelector(FString&,EDLCSelector)", result, SelectedDLC); }
	static void OpenStorePageForDLC() { NativeCall<void>(nullptr, "UVictoryCore.OpenStorePageForDLC()"); }
	static TArray<AActor*, TSizedDefaultAllocator<32> >* SortActorsByDistance(TArray<AActor*, TSizedDefaultAllocator<32> >* result, const UE::Math::TVector<double>* fromLoc, const TArray<AActor*, TSizedDefaultAllocator<32> >* actors) { return NativeCall<TArray<AActor*, TSizedDefaultAllocator<32> >*, TArray<AActor*, TSizedDefaultAllocator<32> >*, const UE::Math::TVector<double>*, const TArray<AActor*, TSizedDefaultAllocator<32> >*>(nullptr, "UVictoryCore.SortActorsByDistance(TArray<AActor*,TSizedDefaultAllocator<32>>*,UE::Math::TVector<double>*,TArray<AActor*,TSizedDefaultAllocator<32>>*)", result, fromLoc, actors); }
	static void PlayMusic() { NativeCall<void>(nullptr, "UVictoryCore.PlayMusic()"); }
	static void StopMusic() { NativeCall<void>(nullptr, "UVictoryCore.StopMusic()"); }
	static UClass* BPLoadClass(const FString* PathName) { return NativeCall<UClass*, const FString*>(nullptr, "UVictoryCore.BPLoadClass(FString&)", PathName); }
	//static bool VTraceAgainstActorExpensive(UObject* WorldContextObject, const UE::Math::TVector<double>* Start, const UE::Math::TVector<double>* End, FHitResult* HitOut, AActor* ActorToTraceAgainst, ECollisionChannel Channel, __int64 CollisionGroups, float SphereRadius, bool bReturnPhysMaterial, bool bTraceComplex, const UE::Math::TVector<double>* BoxExtent, FName TraceTag, bool bSort) { return NativeCall<bool, UObject*, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*, FHitResult*, AActor*, ECollisionChannel, __int64, float, bool, bool, const UE::Math::TVector<double>*, FName, bool>(nullptr, "UVictoryCore.VTraceAgainstActorExpensive(UObject*,UE::Math::TVector<double>*,UE::Math::TVector<double>*,FHitResult*,AActor*,ECollisionChannel,__int64,float,bool,bool,UE::Math::TVector<double>*,FName,bool)", WorldContextObject, Start, End, HitOut, ActorToTraceAgainst, Channel, CollisionGroups, SphereRadius, bReturnPhysMaterial, bTraceComplex, BoxExtent, TraceTag, bSort); }
	//static TSubclassOf<UObject>* StringReferenceToClass(TSubclassOf<UObject>* result, const FString* StringReference) { return NativeCall<TSubclassOf<UObject> *, TSubclassOf<UObject>*, const FString*>(nullptr, "UVictoryCore.StringReferenceToClass(TSubclassOf<UObject>*,FString&)", result, StringReference); }
	static void RefreshApplySoundVolumes() { NativeCall<void>(nullptr, "UVictoryCore.RefreshApplySoundVolumes()"); }
	static void RefreshApplySoundAndMusicVolumes() { NativeCall<void>(nullptr, "UVictoryCore.RefreshApplySoundAndMusicVolumes()"); }
	static FString* GetTwoLetterISOLanguageName(FString* result) { return NativeCall<FString*, FString*>(nullptr, "UVictoryCore.GetTwoLetterISOLanguageName(FString&)", result); }
	static FString* GetSoundWaveLocalizedSpokenText(FString* result, USoundWave* inSound) { return NativeCall<FString*, FString*, USoundWave*>(nullptr, "UVictoryCore.GetSoundWaveLocalizedSpokenText(FString&,USoundWave*)", result, inSound); }
	static FString* GetSoundCueLocalizedSpokenText(FString* result, USoundCue* inSound) { return NativeCall<FString*, FString*, USoundCue*>(nullptr, "UVictoryCore.GetSoundCueLocalizedSpokenText(FString&,USoundCue*)", result, inSound); }
	static bool GetLocaleSpecificAudio(const TArray<FLocalizedSoundCueEntry, TSizedDefaultAllocator<32> >* LocalizedSoundCues, FLocalizedSoundCueEntry* OutLocalizedAudio, const FString* LanguageOverride) { return NativeCall<bool, const TArray<FLocalizedSoundCueEntry, TSizedDefaultAllocator<32> >*, FLocalizedSoundCueEntry*, const FString*>(nullptr, "UVictoryCore.GetLocaleSpecificAudio(TArray<FLocalizedSoundCueEntry,TSizedDefaultAllocator<32>>*,FLocalizedSoundCueEntry*,FString&)", LocalizedSoundCues, OutLocalizedAudio, LanguageOverride); }
	static bool GetLocaleSpecificSoundWaveAnimTexturePairArrays(const TArray<FLocalizedSoundWaveAnimTexturePairArrays, TSizedDefaultAllocator<32> >* LocalizedSoundWaveAnimTextures, FLocalizedSoundWaveAnimTexturePairArrays* OutLocalizedAudio, bool* FoundLocalizedSoundWavesForThisLanguage, const FString* LanguageOverride) { return NativeCall<bool, const TArray<FLocalizedSoundWaveAnimTexturePairArrays, TSizedDefaultAllocator<32> >*, FLocalizedSoundWaveAnimTexturePairArrays*, bool*, const FString*>(nullptr, "UVictoryCore.GetLocaleSpecificSoundWaveAnimTexturePairArrays(TArray<FLocalizedSoundWaveAnimTexturePairArrays,TSizedDefaultAllocator<32>>*,FLocalizedSoundWaveAnimTexturePairArrays*,bool*,FString&)", LocalizedSoundWaveAnimTextures, OutLocalizedAudio, FoundLocalizedSoundWavesForThisLanguage, LanguageOverride); }
	static FString* FindLocalizedVersionOfFilename(FString* result, const FSoftObjectPath* OriginalFile) { return NativeCall<FString*, FString*, const FSoftObjectPath*>(nullptr, "UVictoryCore.FindLocalizedVersionOfFilename(FString&,FSoftObjectPath*)", result, OriginalFile); }
	static void AddEnvironmentInteractionEffect() { NativeCall<void>(nullptr, "UVictoryCore.AddEnvironmentInteractionEffect()"); }
	static void AddEnvironmentCapsuleInteractionEffect() { NativeCall<void>(nullptr, "UVictoryCore.AddEnvironmentCapsuleInteractionEffect()"); }
	static void AddFluidInteraction() { NativeCall<void>(nullptr, "UVictoryCore.AddFluidInteraction()"); }
	static char IsLocationLikelyWithinAnIncorrectlyPlacedWaterVolume() { return NativeCall<char>(nullptr, "UVictoryCore.IsLocationLikelyWithinAnIncorrectlyPlacedWaterVolume()"); }
	static FString* GetTotalCoversionIdAsString(FString* result) { return NativeCall<FString*, FString*>(nullptr, "UVictoryCore.GetTotalCoversionIdAsString(FString&)", result); }
	static UClass* GetItemClassFromItemSetup(const FItemSetup* ItemSetup) { return NativeCall<UClass*, const FItemSetup*>(nullptr, "UVictoryCore.GetItemClassFromItemSetup(FItemSetup*)", ItemSetup); }
	//static bool GetCharacterCapsuleSize(TSubclassOf<APrimalCharacter> CharClass, float* OutCapsuleRadius, float* OutCapsuleHalfHeight) { return NativeCall<bool, TSubclassOf<APrimalCharacter>, float*, float*>(nullptr, "UVictoryCore.GetCharacterCapsuleSize(TSubclassOf<APrimalCharacter>,float*,float*)", CharClass, OutCapsuleRadius, OutCapsuleHalfHeight); }
	static UClass* GetDinoStaticClass(const FDinoSetup* DinoSetup) { return NativeCall<UClass*, const FDinoSetup*>(nullptr, "UVictoryCore.GetDinoStaticClass(FDinoSetup*)", DinoSetup); }
	//static APrimalDinoCharacter* SpawnCustomDino(UObject* WorldContextObject, const UE::Math::TVector<double>* SpawnLocation, const UE::Math::TRotator<double>* SpawnRotation, const FDinoSetup* DinoSetup, AShooterPlayerController* OwnerPlayerController, float DebugDrawDuration, bool bApplyRotationToSpawnOffset, bool bUseExactSpawnLocation, bool bSkipAddingTamedLevels, bool bSuppressTamingNotifications, AMissionType* mission, TSubclassOf<UPrimalColorSet> ColorSet) { return NativeCall<APrimalDinoCharacter*, UObject*, const UE::Math::TVector<double>*, const UE::Math::TRotator<double>*, const FDinoSetup*, AShooterPlayerController*, float, bool, bool, bool, bool, AMissionType*, TSubclassOf<UPrimalColorSet>>(nullptr, "UVictoryCore.SpawnCustomDino(UObject*,UE::Math::TVector<double>*,UE::Math::TRotator<double>*,FDinoSetup*,AShooterPlayerController*,float,bool,bool,bool,bool,AMissionType*,TSubclassOf<UPrimalColorSet>)", WorldContextObject, SpawnLocation, SpawnRotation, DinoSetup, OwnerPlayerController, DebugDrawDuration, bApplyRotationToSpawnOffset, bUseExactSpawnLocation, bSkipAddingTamedLevels, bSuppressTamingNotifications, mission, ColorSet); }
	static bool CanSpawnCustomDino(UObject* WorldContextObject, UE::Math::TVector<double>* OutCalculatedSpawnLocation, const UE::Math::TVector<double>* PlayerLocation, const UE::Math::TVector<double>* SpawnLocation, const UE::Math::TRotator<double>* SpawnRotation, const FDinoSetup* DinoSetup, float DebugDrawDuration, bool bDoLosCheck, bool bDoExtraSafetyChecks, APrimalCharacter* spawningCharacter, bool bDoOverlapCheck) { return NativeCall<bool, UObject*, UE::Math::TVector<double>*, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*, const UE::Math::TRotator<double>*, const FDinoSetup*, float, bool, bool, APrimalCharacter*, bool>(nullptr, "UVictoryCore.CanSpawnCustomDino(UObject*,UE::Math::TVector<double>*,UE::Math::TVector<double>*,UE::Math::TVector<double>*,UE::Math::TRotator<double>*,FDinoSetup*,float,bool,bool,APrimalCharacter*,bool)", WorldContextObject, OutCalculatedSpawnLocation, PlayerLocation, SpawnLocation, SpawnRotation, DinoSetup, DebugDrawDuration, bDoLosCheck, bDoExtraSafetyChecks, spawningCharacter, bDoOverlapCheck); }
	static int CountCharactersResolvingGroundLocationInSphere(UWorld* WorldContext, const UE::Math::TVector<double>* location, float radius) { return NativeCall<int, UWorld*, const UE::Math::TVector<double>*, float>(nullptr, "UVictoryCore.CountCharactersResolvingGroundLocationInSphere(UWorld*,UE::Math::TVector<double>*,float)", WorldContext, location, radius); }
	static bool GetDinoSetupGroup_ByName(FName GroupName, const TArray<FDinoSetupGroup, TSizedDefaultAllocator<32> >* DinoSetupGroups, FDinoSetupGroup* OutGroup) { return NativeCall<bool, FName, const TArray<FDinoSetupGroup, TSizedDefaultAllocator<32> >*, FDinoSetupGroup*>(nullptr, "UVictoryCore.GetDinoSetupGroup_ByName(FName,TArray<FDinoSetupGroup,TSizedDefaultAllocator<32>>*,FDinoSetupGroup*)", GroupName, DinoSetupGroups, OutGroup); }
	static bool GetDinoSetupGroup_WeightedRandom(const TArray<FDinoSetupGroup, TSizedDefaultAllocator<32> >* DinoSetupGroups, FDinoSetupGroup* OutGroup) { return NativeCall<bool, const TArray<FDinoSetupGroup, TSizedDefaultAllocator<32> >*, FDinoSetupGroup*>(nullptr, "UVictoryCore.GetDinoSetupGroup_WeightedRandom(TArray<FDinoSetupGroup,TSizedDefaultAllocator<32>>*,FDinoSetupGroup*)", DinoSetupGroups, OutGroup); }
	static void ForEachAvailableMissionType(UWorld* World, const TFunction<bool __cdecl(FAvailableMission const&)>* Callback) { NativeCall<void, UWorld*, const TFunction<bool __cdecl(FAvailableMission const&)>*>(nullptr, "UVictoryCore.ForEachAvailableMissionType(UWorld*,TFunction<bool__cdecl(FAvailableMission&)>*)", World, Callback); }
	static TArray<FAvailableMission, TSizedDefaultAllocator<32> >* GetAllAvailableMissions(TArray<FAvailableMission, TSizedDefaultAllocator<32> >* result, UObject* WorldContextObject) { return NativeCall<TArray<FAvailableMission, TSizedDefaultAllocator<32> >*, TArray<FAvailableMission, TSizedDefaultAllocator<32> >*, UObject*>(nullptr, "UVictoryCore.GetAllAvailableMissions(TArray<FAvailableMission,TSizedDefaultAllocator<32>>*,UObject*)", result, WorldContextObject); }
	static TArray<FName, TSizedDefaultAllocator<32> >* GetAllAvailableMissionsAsTags(TArray<FName, TSizedDefaultAllocator<32> >* result, UObject* WorldContextObject) { return NativeCall<TArray<FName, TSizedDefaultAllocator<32> >*, TArray<FName, TSizedDefaultAllocator<32> >*, UObject*>(nullptr, "UVictoryCore.GetAllAvailableMissionsAsTags(TArray<FName,TSizedDefaultAllocator<32>>*,UObject*)", result, WorldContextObject); }
	static TArray<AActor*, TSizedDefaultAllocator<32> >* GetAllMissionActors(TArray<AActor*, TSizedDefaultAllocator<32> >* result, UObject* WorldContextObject) { return NativeCall<TArray<AActor*, TSizedDefaultAllocator<32> >*, TArray<AActor*, TSizedDefaultAllocator<32> >*, UObject*>(nullptr, "UVictoryCore.GetAllMissionActors(TArray<AActor*,TSizedDefaultAllocator<32>>*,UObject*)", result, WorldContextObject); }
	//static AActor* GetMissionActorOfType(UObject* WorldContextObject, TSubclassOf<AMissionType> theMissionType, bool bExactMatch) { return NativeCall<AActor*, UObject*, TSubclassOf<AMissionType>, bool>(nullptr, "UVictoryCore.GetMissionActorOfType(UObject*,TSubclassOf<AMissionType>,bool)", WorldContextObject, theMissionType, bExactMatch); }
	static TArray<AActor*, TSizedDefaultAllocator<32> >* GetAllMissionDispatchers(TArray<AActor*, TSizedDefaultAllocator<32> >* result, UObject* WorldContextObject) { return NativeCall<TArray<AActor*, TSizedDefaultAllocator<32> >*, TArray<AActor*, TSizedDefaultAllocator<32> >*, UObject*>(nullptr, "UVictoryCore.GetAllMissionDispatchers(TArray<AActor*,TSizedDefaultAllocator<32>>*,UObject*)", result, WorldContextObject); }
	static TArray<AActor*, TSizedDefaultAllocator<32> >* GetAllMissionDispatcherPoints(TArray<AActor*, TSizedDefaultAllocator<32> >* result, UObject* WorldContextObject) { return NativeCall<TArray<AActor*, TSizedDefaultAllocator<32> >*, TArray<AActor*, TSizedDefaultAllocator<32> >*, UObject*>(nullptr, "UVictoryCore.GetAllMissionDispatcherPoints(TArray<AActor*,TSizedDefaultAllocator<32>>*,UObject*)", result, WorldContextObject); }
	//static TSubclassOf<UPrimalItem>* GenerateRandomLootItem(TSubclassOf<UPrimalItem>* result, TEnumAsByte<enum ELootItemType::Type> LootItemType) { return NativeCall<TSubclassOf<UPrimalItem> *, TSubclassOf<UPrimalItem>*, TEnumAsByte<enum ELootItemType::Type>>(nullptr, "UVictoryCore.GenerateRandomLootItem(TSubclassOf<UPrimalItem>*,TEnumAsByte<enumELootItemType::Type>)", result, LootItemType); }
	//static TSubclassOf<UPrimalItem>* GenerateRandomLootItemFromLootTable(TSubclassOf<UPrimalItem>* result, const TArray<FLootTableEntry, TSizedDefaultAllocator<32> >* Entries, int* OutItemQuantity, float* OutItemQuality) { return NativeCall<TSubclassOf<UPrimalItem> *, TSubclassOf<UPrimalItem>*, const TArray<FLootTableEntry, TSizedDefaultAllocator<32> >*, int*, float*>(nullptr, "UVictoryCore.GenerateRandomLootItemFromLootTable(TSubclassOf<UPrimalItem>*,TArray<FLootTableEntry,TSizedDefaultAllocator<32>>*,int*,float*)", result, Entries, OutItemQuantity, OutItemQuality); }
	//static TArray<UPrimalItem*, TSizedDefaultAllocator<32> >* GiveItemToCharacter(TArray<UPrimalItem*, TSizedDefaultAllocator<32> >* result, APrimalCharacter* Character, TSubclassOf<UPrimalItem> ItemType, int NumItems, float Quality, bool bAutoEquip) { return NativeCall<TArray<UPrimalItem*, TSizedDefaultAllocator<32> >*, TArray<UPrimalItem*, TSizedDefaultAllocator<32> >*, APrimalCharacter*, TSubclassOf<UPrimalItem>, int, float, bool>(nullptr, "UVictoryCore.GiveItemToCharacter(TArray<UPrimalItem*,TSizedDefaultAllocator<32>>*,APrimalCharacter*,TSubclassOf<UPrimalItem>,int,float,bool)", result, Character, ItemType, NumItems, Quality, bAutoEquip); }
	static void GetObjectsReferencedBy(UObject* ForObject, TArray<UObject*, TSizedDefaultAllocator<32> >* OutReferencedObjects, bool bIgnoreTransient) { NativeCall<void, UObject*, TArray<UObject*, TSizedDefaultAllocator<32> >*, bool>(nullptr, "UVictoryCore.GetObjectsReferencedBy(UObject*,TArray<UObject*,TSizedDefaultAllocator<32>>*,bool)", ForObject, OutReferencedObjects, bIgnoreTransient); }
	static bool GetOverlappedHarvestActors(UObject* WorldContextObject, const UE::Math::TVector<double>* AtLoc, float AtRadius, TArray<AActor*, TSizedDefaultAllocator<32> >* OutHarvestActors, TArray<UActorComponent*, TSizedDefaultAllocator<32> >* OutHarvestComponents, TArray<UE::Math::TVector<double>, TSizedDefaultAllocator<32> >* OutHarvestLocations, TArray<int, TSizedDefaultAllocator<32> >* OutHitBodyIndices) { return NativeCall<bool, UObject*, const UE::Math::TVector<double>*, float, TArray<AActor*, TSizedDefaultAllocator<32> >*, TArray<UActorComponent*, TSizedDefaultAllocator<32> >*, TArray<UE::Math::TVector<double>, TSizedDefaultAllocator<32> >*, TArray<int, TSizedDefaultAllocator<32> >*>(nullptr, "UVictoryCore.GetOverlappedHarvestActors(UObject*,UE::Math::TVector<double>*,float,TArray<AActor*,TSizedDefaultAllocator<32>>*,TArray<UActorComponent*,TSizedDefaultAllocator<32>>*,TArray<UE::Math::TVector<double>,TSizedDefaultAllocator<32>>*,TArray<int,TSizedDefaultAllocator<32>>*)", WorldContextObject, AtLoc, AtRadius, OutHarvestActors, OutHarvestComponents, OutHarvestLocations, OutHitBodyIndices); }
	static void ServerSearchFoliage() { NativeCall<void>(nullptr, "UVictoryCore.ServerSearchFoliage()"); }
	static FName* GetHitBoneNameFromDamageEvent(FName* result, APrimalCharacter* Character, AController* HitInstigator, const FDamageEvent* DamageEvent, bool bIsPointDamage, const FHitResult* PointHitResult, FName MatchCollisionPresetName) { return NativeCall<FName*, FName*, APrimalCharacter*, AController*, const FDamageEvent*, bool, const FHitResult*, FName>(nullptr, "UVictoryCore.GetHitBoneNameFromDamageEvent(FName*,APrimalCharacter*,AController*,FDamageEvent*,bool,FHitResult*,FName)", result, Character, HitInstigator, DamageEvent, bIsPointDamage, PointHitResult, MatchCollisionPresetName); }
	static float GetAngleBetweenVectors(const UE::Math::TVector<double>* VectorA, const UE::Math::TVector<double>* VectorB, const UE::Math::TVector<double>* AroundAxis) { return NativeCall<float, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*>(nullptr, "UVictoryCore.GetAngleBetweenVectors(UE::Math::TVector<double>*,UE::Math::TVector<double>*,UE::Math::TVector<double>*)", VectorA, VectorB, AroundAxis); }
	static float GetAngleBetweenVectorsPure() { return NativeCall<float>(nullptr, "UVictoryCore.GetAngleBetweenVectorsPure()"); }
	static bool AreRotatorsNearlyEqual(const UE::Math::TRotator<double>* RotatorA, const UE::Math::TRotator<double>* RotatorB, float WithinError) { return NativeCall<bool, const UE::Math::TRotator<double>*, const UE::Math::TRotator<double>*, float>(nullptr, "UVictoryCore.AreRotatorsNearlyEqual(UE::Math::TRotator<double>*,UE::Math::TRotator<double>*,float)", RotatorA, RotatorB, WithinError); }
	static bool AreTransformsNearlyEqual(const UE::Math::TTransform<double>* TransformA, const UE::Math::TTransform<double>* TransformB, float WithinError) { return NativeCall<bool, const UE::Math::TTransform<double>*, const UE::Math::TTransform<double>*, float>(nullptr, "UVictoryCore.AreTransformsNearlyEqual(UE::Math::TTransform<double>*,UE::Math::TTransform<double>*,float)", TransformA, TransformB, WithinError); }
	static void MulticastDrawDebugLine() { NativeCall<void>(nullptr, "UVictoryCore.MulticastDrawDebugLine()"); }
	static AShooterCharacter* GetPlayerCharacterByController(APlayerController* PC) { return NativeCall<AShooterCharacter*, APlayerController*>(nullptr, "UVictoryCore.GetPlayerCharacterByController(APlayerController*)", PC); }
	static APrimalDinoCharacter* GetDinoCharacterByID(UObject* WorldContextObject, const int DinoID1, const int DinoID2, const bool bSearchTamedOnly) { return NativeCall<APrimalDinoCharacter*, UObject*, const int, const int, const bool>(nullptr, "UVictoryCore.GetDinoCharacterByID(UObject*,int,int,bool)", WorldContextObject, DinoID1, DinoID2, bSearchTamedOnly); }
	static APrimalDinoCharacter* GetDinoCharacterByLongDinoID(UObject* WorldContextObject, const FString* DinoID, const bool bSearchTamedOnly) { return NativeCall<APrimalDinoCharacter*, UObject*, const FString*, const bool>(nullptr, "UVictoryCore.GetDinoCharacterByLongDinoID(UObject*,FString&,bool)", WorldContextObject, DinoID, bSearchTamedOnly); }
	static void GetAllClassesOfType() { NativeCall<void>(nullptr, "UVictoryCore.GetAllClassesOfType()"); }
	static bool IsValidItemForGrinding(const UPrimalItem* item, const UPrimalInventoryComponent* inventory) { return NativeCall<bool, const UPrimalItem*, const UPrimalInventoryComponent*>(nullptr, "UVictoryCore.IsValidItemForGrinding(UPrimalItem*,UPrimalInventoryComponent*)", item, inventory); }
	static bool GrindItemIntoInventory(UPrimalItem* item, UPrimalInventoryComponent* inventory, const bool bGrindStack, const int MaxQuantityToGrind, const float GrindGiveItemsPercent, const int MaxItemsToGivePerGrind) { return NativeCall<bool, UPrimalItem*, UPrimalInventoryComponent*, const bool, const int, const float, const int>(nullptr, "UVictoryCore.GrindItemIntoInventory(UPrimalItem*,UPrimalInventoryComponent*,bool,int,float,int)", item, inventory, bGrindStack, MaxQuantityToGrind, GrindGiveItemsPercent, MaxItemsToGivePerGrind); }
	static void GrindAllItemsToInventory(UPrimalInventoryComponent* inventory, const bool bGrindStack, const int MaxQuantityToGrind, const float GrindGiveItemsPercent, const int MaxItemsToGivePerGrind) { NativeCall<void, UPrimalInventoryComponent*, const bool, const int, const float, const int>(nullptr, "UVictoryCore.GrindAllItemsToInventory(UPrimalInventoryComponent*,bool,int,float,int)", inventory, bGrindStack, MaxQuantityToGrind, GrindGiveItemsPercent, MaxItemsToGivePerGrind); }
	//static TSubclassOf<UPrimalItem>* GetGrinderReplacementItem(TSubclassOf<UPrimalItem>* result, TSubclassOf<UPrimalItem> current) { return NativeCall<TSubclassOf<UPrimalItem> *, TSubclassOf<UPrimalItem>*, TSubclassOf<UPrimalItem>>(nullptr, "UVictoryCore.GetGrinderReplacementItem(TSubclassOf<UPrimalItem>*,TSubclassOf<UPrimalItem>)", result, current); }
	static bool HasPlayerSeenGen2Intro(UObject* WorldContextObject) { return NativeCall<bool, UObject*>(nullptr, "UVictoryCore.HasPlayerSeenGen2Intro(UObject*)", WorldContextObject); }
	static void MarkGen2IntroAsSeen(UObject* WorldContextObject) { NativeCall<void, UObject*>(nullptr, "UVictoryCore.MarkGen2IntroAsSeen(UObject*)", WorldContextObject); }
	static void ForceScreenColorFade() { NativeCall<void>(nullptr, "UVictoryCore.ForceScreenColorFade()"); }
	static float GetScreenPercentage() { return NativeCall<float>(nullptr, "UVictoryCore.GetScreenPercentage()"); }
	static bool ProjectWorldToScreenPositionRaw() { return NativeCall<bool>(nullptr, "UVictoryCore.ProjectWorldToScreenPositionRaw()"); }
	static char ProjectWorldLocationToScreenOrScreenEdgePosition() { return NativeCall<char>(nullptr, "UVictoryCore.ProjectWorldLocationToScreenOrScreenEdgePosition()"); }
	static void AdjustScreenPositionWithScreenDPI(UObject* WorldContextObject, UE::Math::TVector2<double>* ScreenPosition) { NativeCall<void, UObject*, UE::Math::TVector2<double>*>(nullptr, "UVictoryCore.AdjustScreenPositionWithScreenDPI(UObject*,UE::Math::TVector2<double>*)", WorldContextObject, ScreenPosition); }
	static bool IsPointStuckWithinMesh() { return NativeCall<bool>(nullptr, "UVictoryCore.IsPointStuckWithinMesh()"); }
	static bool ServerCheckMeshingOnActor(AActor* OnActor, bool bForceUseActorCenterBounds) { return NativeCall<bool, AActor*, bool>(nullptr, "UVictoryCore.ServerCheckMeshingOnActor(AActor*,bool)", OnActor, bForceUseActorCenterBounds); }
	static void PlayCompanionReactionToPlayers() { NativeCall<void>(nullptr, "UVictoryCore.PlayCompanionReactionToPlayers()"); }
	static void PlayCompanionReactionOnSolePlayer(APrimalCharacter* PlayerWhoGetReaction, FCompanionReactionData* ReactionData, const bool ForcePlayNow, UMaterialInterface* OverrideDialogueIcon, const bool RestrictedEnvironmentalReaction, const int UniqueID) { NativeCall<void, APrimalCharacter*, FCompanionReactionData*, const bool, UMaterialInterface*, const bool, const int>(nullptr, "UVictoryCore.PlayCompanionReactionOnSolePlayer(APrimalCharacter*,FCompanionReactionData*,bool,UMaterialInterface*,bool,int)", PlayerWhoGetReaction, ReactionData, ForcePlayNow, OverrideDialogueIcon, RestrictedEnvironmentalReaction, UniqueID); }
	static void SetMaterialColorizationFromItemColors(UPrimalItem* item, UMaterialInstanceDynamic* dynamicMic) { NativeCall<void, UPrimalItem*, UMaterialInstanceDynamic*>(nullptr, "UVictoryCore.SetMaterialColorizationFromItemColors(UPrimalItem*,UMaterialInstanceDynamic*)", item, dynamicMic); }
	static FString* ConvertIntToStringWithCommas(FString* result, int GivenNumber) { return NativeCall<FString*, FString*, int>(nullptr, "UVictoryCore.ConvertIntToStringWithCommas(FString&,int)", result, GivenNumber); }
	static float GetSimpleMontageDuration(UAnimMontage* GivenMontage, float GivenPlayRate) { return NativeCall<float, UAnimMontage*, float>(nullptr, "UVictoryCore.GetSimpleMontageDuration(UAnimMontage*,float)", GivenMontage, GivenPlayRate); }
	static void PrintMessageInShippingBuild(const FString* msg) { NativeCall<void, const FString*>(nullptr, "UVictoryCore.PrintMessageInShippingBuild(FString&)", msg); }
	static bool IsDinoDuped(UObject* WorldContextObject, const int id1, const int id2) { return NativeCall<bool, UObject*, const int, const int>(nullptr, "UVictoryCore.IsDinoDuped(UObject*,int,int)", WorldContextObject, id1, id2); }
	static bool IsUnderMesh(APrimalCharacter* Character, UE::Math::TVector<double>* CheckSevenHitLocation, bool* bOverlapping, UActorComponent** CheckSevenResult, bool DebugDraw, float DebugDrawSeconds) { return NativeCall<bool, APrimalCharacter*, UE::Math::TVector<double>*, bool*, UActorComponent**, bool, float>(nullptr, "UVictoryCore.IsUnderMesh(APrimalCharacter*,UE::Math::TVector<double>*,bool*,UActorComponent**,bool,float)", Character, CheckSevenHitLocation, bOverlapping, CheckSevenResult, DebugDraw, DebugDrawSeconds); }
	static FString* BPGetPrimaryMapName(FString* result, UObject* WorldContextObject) { return NativeCall<FString*, FString*, UObject*>(nullptr, "UVictoryCore.BPGetPrimaryMapName(FString&,UObject*)", result, WorldContextObject); }
	static FString* SimpleReplaceUnicodeWithSupportedAlternatives(FString* result, const FString* OriginalString) { return NativeCall<FString*, FString*, const FString*>(nullptr, "UVictoryCore.SimpleReplaceUnicodeWithSupportedAlternatives(FString&,FString&)", result, OriginalString); }
	static AActor* SpawnSaddleAttachedStructure() { return NativeCall<AActor*>(nullptr, "UVictoryCore.SpawnSaddleAttachedStructure()"); }
	static void DisableGCM(AActor* targetActor) { NativeCall<void, AActor*>(nullptr, "UVictoryCore.DisableGCM(AActor*)", targetActor); }
	static TArray<FString, TSizedDefaultAllocator<32> >* ChunkFStringIntoArray() { return NativeCall<TArray<FString, TSizedDefaultAllocator<32> >*>(nullptr, "UVictoryCore.ChunkFStringIntoArray()"); }
	static bool IsBrainControllingDinoAttached(APrimalCharacter* character) { return NativeCall<bool, APrimalCharacter*>(nullptr, "UVictoryCore.IsBrainControllingDinoAttached(APrimalCharacter*)", character); }
	static long double GetMissionNetworkStartTime(UObject* WorldContextObject, FName MissionTag) { return NativeCall<long double, UObject*, FName>(nullptr, "UVictoryCore.GetMissionNetworkStartTime(UObject*,FName)", WorldContextObject, MissionTag); }
	static TArray<FName, TSizedDefaultAllocator<32> >* GetLoadedStreamingLevelNames(TArray<FName, TSizedDefaultAllocator<32> >* result) { return NativeCall<TArray<FName, TSizedDefaultAllocator<32> >*, TArray<FName, TSizedDefaultAllocator<32> >*>(nullptr, "UVictoryCore.GetLoadedStreamingLevelNames(TArray<FName,TSizedDefaultAllocator<32>>*)", result); }
	static void BlockTillAllStreamingRequestsFinished() { NativeCall<void>(nullptr, "UVictoryCore.BlockTillAllStreamingRequestsFinished()"); }
	static AActor* DeferredSpawnAndFireProjectile_Start() { return NativeCall<AActor*>(nullptr, "UVictoryCore.DeferredSpawnAndFireProjectile_Start()"); }
	static void ViewTrailer(bool bAnimatedSeriesTrailer, bool bARK2Trailer) { NativeCall<void, bool, bool>(nullptr, "UVictoryCore.ViewTrailer(bool,bool)", bAnimatedSeriesTrailer, bARK2Trailer); }
	static FString* FuseChunkedFString() { return NativeCall<FString*>(nullptr, "UVictoryCore.FuseChunkedFString()"); }
	static char ClipLineInsideBox() { return NativeCall<char>(nullptr, "UVictoryCore.ClipLineInsideBox()"); }
	static void GetLaunchVelocityAndGravity() { NativeCall<void>(nullptr, "UVictoryCore.GetLaunchVelocityAndGravity()"); }
	static void RecordMeshingMetrics(AActor* ForActor, bool bWasDestoryed) { NativeCall<void, AActor*, bool>(nullptr, "UVictoryCore.RecordMeshingMetrics(AActor*,bool)", ForActor, bWasDestoryed); }
	static void DestroyAllCharactersWithinMissionTileVolumes(UObject* WorldContextObject, bool bOnlyCheckForDeadCharacters, FName ForceOnTileStreamVolumeCustomTag) { NativeCall<void, UObject*, bool, FName>(nullptr, "UVictoryCore.DestroyAllCharactersWithinMissionTileVolumes(UObject*,bool,FName)", WorldContextObject, bOnlyCheckForDeadCharacters, ForceOnTileStreamVolumeCustomTag); }
	//static bool IsMissionActiveAnywhere(TSubclassOf<AMissionType> MissionType) { return NativeCall<bool, TSubclassOf<AMissionType>>(nullptr, "UVictoryCore.IsMissionActiveAnywhere(TSubclassOf<AMissionType>)", MissionType); }
	static bool IsMissionTagActiveAnywhere(AShooterPlayerController* FromPC, FName MissionTag) { return NativeCall<bool, AShooterPlayerController*, FName>(nullptr, "UVictoryCore.IsMissionTagActiveAnywhere(AShooterPlayerController*,FName)", FromPC, MissionTag); }
	static FName* GetBlockingMissionTag(FName* result, AShooterPlayerController* FromPC, FName MissionTag) { return NativeCall<FName*, FName*, AShooterPlayerController*, FName>(nullptr, "UVictoryCore.GetBlockingMissionTag(FName*,AShooterPlayerController*,FName)", result, FromPC, MissionTag); }
	static bool TryGetLocalizedString() { return NativeCall<bool>(nullptr, "UVictoryCore.TryGetLocalizedString()"); }
	static void GetAllActorsOfClassSoft() { NativeCall<void>(nullptr, "UVictoryCore.GetAllActorsOfClassSoft()"); }
	static FString* ListDinos(FString* result, UObject* WorldContextObject, const bool TamedOnly, const int TargetingTeamExcluded) { return NativeCall<FString*, FString*, UObject*, const bool, const int>(nullptr, "UVictoryCore.ListDinos(FString&,UObject*,bool,int)", result, WorldContextObject, TamedOnly, TargetingTeamExcluded); }
	static FString* ListDinosNew(FString* result, UObject* WorldContextObject) { return NativeCall<FString*, FString*, UObject*>(nullptr, "UVictoryCore.ListDinosNew(FString&,UObject*)", result, WorldContextObject); }
	static bool EnsureNumericAndCharsEx(FString* text, int maxChars, bool bAllowSpace) { return NativeCall<bool, FString*, int, bool>(nullptr, "UVictoryCore.EnsureNumericAndCharsEx(FString&,int,bool)", text, maxChars, bAllowSpace); }
	static TArray<APrimalDinoCharacter*, TSizedDefaultAllocator<32> >* AttemptToSpawnAWildFollower() { return NativeCall<TArray<APrimalDinoCharacter*, TSizedDefaultAllocator<32> >*>(nullptr, "UVictoryCore.AttemptToSpawnAWildFollower()"); }
	static TArray<APrimalDinoCharacter*, TSizedDefaultAllocator<32> >* SpawnFollowerBasedOnRNG() { return NativeCall<TArray<APrimalDinoCharacter*, TSizedDefaultAllocator<32> >*>(nullptr, "UVictoryCore.SpawnFollowerBasedOnRNG()"); }
	static APrimalDinoCharacter* SpawnFollower() { return NativeCall<APrimalDinoCharacter*>(nullptr, "UVictoryCore.SpawnFollower()"); }
	static FPrimalPlayerCharacterConfigStructReplicated* MakePlayerCharacterConfigStructReplicated() { return NativeCall<FPrimalPlayerCharacterConfigStructReplicated*>(nullptr, "UVictoryCore.MakePlayerCharacterConfigStructReplicated()"); }
	static void BreakPlayerCharacterConfigStructReplicated(const FPrimalPlayerCharacterConfigStructReplicated* FromStruct, bool* bIsFemale, TArray<FLinearColor, TSizedDefaultAllocator<32> >* BodyColors, FString* PlayerCharacterName, TArray<float, TSizedDefaultAllocator<32> >* RawBoneModifiers, int* PlayerSpawnRegionIndex, unsigned __int8* HeadHairIndex, unsigned __int8* FacialHairIndex, float* PercentOfFullHeadHairGrowth, float* PercentOfFullFacialHairGrowth, TArray<unsigned char, TSizedDefaultAllocator<32> >* OverrideHeadHairColor, TArray<unsigned char, TSizedDefaultAllocator<32> >* OverrideFacialHairColor, TArray<unsigned char, TSizedDefaultAllocator<32> >* DynamicMaterialBytes, int PlayerVoiceCollectionIndex, bool* bUsingCustomPlayerVoiceCollection) { NativeCall<void, const FPrimalPlayerCharacterConfigStructReplicated*, bool*, TArray<FLinearColor, TSizedDefaultAllocator<32> >*, FString*, TArray<float, TSizedDefaultAllocator<32> >*, int*, unsigned __int8*, unsigned __int8*, float*, float*, TArray<unsigned char, TSizedDefaultAllocator<32> >*, TArray<unsigned char, TSizedDefaultAllocator<32> >*, TArray<unsigned char, TSizedDefaultAllocator<32> >*, int, bool*>(nullptr, "UVictoryCore.BreakPlayerCharacterConfigStructReplicated(FPrimalPlayerCharacterConfigStructReplicated*,bool*,TArray<FLinearColor,TSizedDefaultAllocator<32>>*,FString&,TArray<float,TSizedDefaultAllocator<32>>*,int*,unsigned__int8*,unsigned__int8*,float*,float*,TArray<unsignedchar,TSizedDefaultAllocator<32>>*,TArray<unsignedchar,TSizedDefaultAllocator<32>>*,TArray<unsignedchar,TSizedDefaultAllocator<32>>*,int,bool*)", FromStruct, bIsFemale, BodyColors, PlayerCharacterName, RawBoneModifiers, PlayerSpawnRegionIndex, HeadHairIndex, FacialHairIndex, PercentOfFullHeadHairGrowth, PercentOfFullFacialHairGrowth, OverrideHeadHairColor, OverrideFacialHairColor, DynamicMaterialBytes, PlayerVoiceCollectionIndex, bUsingCustomPlayerVoiceCollection); }
	static AActor* GetNearestAlliedPlayer() { return NativeCall<AActor*>(nullptr, "UVictoryCore.GetNearestAlliedPlayer()"); }
	static AActor* GetNearestAlliedDinoElsePlayer() { return NativeCall<AActor*>(nullptr, "UVictoryCore.GetNearestAlliedDinoElsePlayer()"); }
	static FKey* GetKeybindByPredicate(FKey* result, FName KeybindName) { return NativeCall<FKey*, FKey*, FName>(nullptr, "UVictoryCore.GetKeybindByPredicate(FKey*,FName)", result, KeybindName); }
	static FText* GetKeybindDisplayName(FText* result, FName Keybind) { return NativeCall<FText*, FText*, FName>(nullptr, "UVictoryCore.GetKeybindDisplayName(FText*,FName)", result, Keybind); }
	static UAnimSequence* GetNearestAnimSequenceFromBlendSpace() { return NativeCall<UAnimSequence*>(nullptr, "UVictoryCore.GetNearestAnimSequenceFromBlendSpace()"); }
	static bool GetAllAnimationSequencesFromMontage(UAnimMontage* InMontage, TArray<UAnimationAsset*, TSizedDefaultAllocator<32> >* AnimationAssets) { return NativeCall<bool, UAnimMontage*, TArray<UAnimationAsset*, TSizedDefaultAllocator<32> >*>(nullptr, "UVictoryCore.GetAllAnimationSequencesFromMontage(UAnimMontage*,TArray<UAnimationAsset*,TSizedDefaultAllocator<32>>*)", InMontage, AnimationAssets); }
	static char GetPreviousTrackedActorLinkedEntry() { return NativeCall<char>(nullptr, "UVictoryCore.GetPreviousTrackedActorLinkedEntry()"); }
	static char GetNextTrackedActorLinkedEntry() { return NativeCall<char>(nullptr, "UVictoryCore.GetNextTrackedActorLinkedEntry()"); }
	static void DoForceStreamComponents(TArray<UMeshComponent*, TSizedDefaultAllocator<32> >* ComponentsArray, bool bIsFirstPerson, bool bForceMaxTexturesOnConsole) { NativeCall<void, TArray<UMeshComponent*, TSizedDefaultAllocator<32> >*, bool, bool>(nullptr, "UVictoryCore.DoForceStreamComponents(TArray<UMeshComponent*,TSizedDefaultAllocator<32>>*,bool,bool)", ComponentsArray, bIsFirstPerson, bForceMaxTexturesOnConsole); }
	//static int IsChildOfClassesSoftRefT<class UObject>(TSubclassOf<UObject> childClass, const //TArray<//TSoftClassPtr<UObject>, TSizedDefaultAllocator<32> >* ParentClassesArray) { return NativeCall<int, TSubclassOf<UObject>, const //TArray<//TSoftClassPtr<UObject>, TSizedDefaultAllocator<32> >*>(nullptr, "UVictoryCore.IsChildOfClassesSoftRefT<class UObject>(TSubclassOf<UObject>,//TArray<//TSoftClassPtr<UObject>,TSizedDefaultAllocator<32>>*)", childClass, ParentClassesArray); }
	//static _BOOL8 OverlappingActorsTrace() { return NativeCall<_BOOL8>(nullptr, "UVictoryCore.OverlappingActorsTrace()"); }
	//static int IsChildOfClassesSoftRefT<class AActor>(TSubclassOf<UObject> childClass, const //TArray<//TSoftClassPtr<AActor>, TSizedDefaultAllocator<32> >* ParentClassesArray) { return NativeCall<int, TSubclassOf<UObject>, const //TArray<//TSoftClassPtr<AActor>, TSizedDefaultAllocator<32> >*>(nullptr, "UVictoryCore.IsChildOfClassesSoftRefT<class AActor>(TSubclassOf<UObject>,//TArray<//TSoftClassPtr<AActor>,TSizedDefaultAllocator<32>>*)", childClass, ParentClassesArray); }
	//static int IsChildOfClassesT<class UPrimalItem>(TSubclassOf<UObject> childClass, const //TArray<TSubclassOf<UPrimalItem>, TSizedDefaultAllocator<32> >* ParentClassesArray) { return NativeCall<int, TSubclassOf<UObject>, const //TArray<TSubclassOf<UPrimalItem>, TSizedDefaultAllocator<32> >*>(nullptr, "UVictoryCore.IsChildOfClassesT<class UPrimalItem>(TSubclassOf<UObject>,//TArray<TSubclassOf<UPrimalItem>,TSizedDefaultAllocator<32>>*)", childClass, ParentClassesArray); }
	//static int IsChildOfClassesSoftRefT<class APrimalStructure>(TSubclassOf<UObject> childClass, const //TArray<//TSoftClassPtr<APrimalStructure>, TSizedDefaultAllocator<32> >* ParentClassesArray) { return NativeCall<int, TSubclassOf<UObject>, const //TArray<//TSoftClassPtr<APrimalStructure>, TSizedDefaultAllocator<32> >*>(nullptr, "UVictoryCore.IsChildOfClassesSoftRefT<class APrimalStructure>(TSubclassOf<UObject>,//TArray<//TSoftClassPtr<APrimalStructure>,TSizedDefaultAllocator<32>>*)", childClass, ParentClassesArray); }
	//static int IsChildOfClassesT<class APrimalStructure>(TSubclassOf<UObject> childClass, const //TArray<TSubclassOf<APrimalStructure>, TSizedDefaultAllocator<32> >* ParentClassesArray) { return NativeCall<int, TSubclassOf<UObject>, const //TArray<TSubclassOf<APrimalStructure>, TSizedDefaultAllocator<32> >*>(nullptr, "UVictoryCore.IsChildOfClassesT<class APrimalStructure>(TSubclassOf<UObject>,//TArray<TSubclassOf<APrimalStructure>,TSizedDefaultAllocator<32>>*)", childClass, ParentClassesArray); }
};

struct FTribeGovernment
{
	int TribeGovern_PINCode;
	int TribeGovern_DinoOwnership;
	int TribeGovern_StructureOwnership;
	int TribeGovern_DinoTaming;
	int TribeGovern_DinoUnclaimAdminOnly;
};

struct FCustomTrackedActorInfo
{
	FString Name;
	float TameAffinityPercent;
	float HealthPercent;
	float HealthCurrent;
	float HealthMax;
	float HungerPercent;
	float HungerCurrent;
	float HungerMax;
	float TorpidityPercent;
	float TameEffectivenessPercent;
	int TameEffectivenessLvlModifier;
	UE::Math::TVector<double> Location;
	bool bIsConcious;
	bool bUseGender;
	bool bIsFemale;
	bool bIsTamed;
	float DinoImprintingQuality;
	float BabyNextCuddleTime;
	float BabyAge;
	float TimeUntilNextNamedAge;
	long double LastTameConsumedFoodTime;
	FString ImprinterName;
	int DataID1;
	int DataID2;
	FString TargetName;
	bool bIsPlayer;
	bool bIsFavorited;
	bool bIsTrackedWaypoint;
	TSubclassOf<UPrimalDinoEntry> DinoEntry;
	bool bHideFromTrackListAndOnlyShowOnMap;
	FString TribeName;
	int TargetingTeam;
	bool bIsVehicle;
	bool bIsValidForCurrentFilter;
	int Level;
	long double TamedAtTime;
	bool POIVisible;
};

struct FTrackedActorPlusInfoStruct
{
	AActor* TrackedActor;
	FCustomTrackedActorInfo ReplicatedInfo;
	UE::Math::TVector<double> ActorLastKnownLocation;
	UE::Math::TVector<double> LastPOILocation;
	int PreviousLinkedListTrackedActorID;
	unsigned __int8 PreviousLinkedListTrackedActorCategory;
	int NextLinkedListTrackedActorID;
	unsigned __int8 NextLinkedListTrackedActorCategory;
};

const struct FTeamPingData
{
	unsigned __int8 PingID;
	UE::Math::TVector<double> Location;
	AActor* ToActor;
	int ByPlayerID;
	int TargetingTeam;
	long double CreationTime;
	TEnumAsByte<enum ETeamPingType::Type> PingType;
	FString PlayerName;
};

struct FTribeData
{
	// Fields

	FString& TribeNameField() { return *GetNativePointerField<FString*>(this, "FTribeData.TribeName"); }
	long double& LastNameChangeTimeField() { return *GetNativePointerField<long double*>(this, "FTribeData.LastNameChangeTime"); }
	unsigned int& OwnerPlayerDataIDField() { return *GetNativePointerField<unsigned int*>(this, "FTribeData.OwnerPlayerDataID"); }
	int& TribeIDField() { return *GetNativePointerField<int*>(this, "FTribeData.TribeID"); }
	TArray<FString>& MembersPlayerNameField() { return *GetNativePointerField<TArray<FString>*>(this, "FTribeData.MembersPlayerName"); }
	TArray<unsigned int>& MembersPlayerDataIDField() { return *GetNativePointerField<TArray<unsigned int>*>(this, "FTribeData.MembersPlayerDataID"); }
	TArray<unsigned char>& MembersRankGroupsField() { return *GetNativePointerField<TArray<unsigned char>*>(this, "FTribeData.MembersRankGroups"); }
	TArray<double>& SlotFreedTimeField() { return *GetNativePointerField<TArray<double>*>(this, "FTribeData.SlotFreedTime"); }
	TArray<unsigned int>& TribeAdminsField() { return *GetNativePointerField<TArray<unsigned int>*>(this, "FTribeData.TribeAdmins"); }
	TArray<FTribeAlliance>& TribeAlliancesField() { return *GetNativePointerField<TArray<FTribeAlliance>*>(this, "FTribeData.TribeAlliances"); }
	bool& bSetGovernmentField() { return *GetNativePointerField<bool*>(this, "FTribeData.bSetGovernment"); }
	FTribeGovernment& TribeGovernmentField() { return *GetNativePointerField<FTribeGovernment*>(this, "FTribeData.TribeGovernment"); }
	TArray<FPrimalPlayerCharacterConfigStruct>& MembersConfigsField() { return *GetNativePointerField<TArray<FPrimalPlayerCharacterConfigStruct>*>(this, "FTribeData.MembersConfigs"); }
	TArray<FTribeWar>& TribeWarsField() { return *GetNativePointerField<TArray<FTribeWar>*>(this, "FTribeData.TribeWars"); }
	TArray<FString>& TribeLogField() { return *GetNativePointerField<TArray<FString>*>(this, "FTribeData.TribeLog"); }
	int& LogIndexField() { return *GetNativePointerField<int*>(this, "FTribeData.LogIndex"); }
	TArray<FTribeRankGroup>& TribeRankGroupsField() { return *GetNativePointerField<TArray<FTribeRankGroup>*>(this, "FTribeData.TribeRankGroups"); }
	int& NumTribeDinosField() { return *GetNativePointerField<int*>(this, "FTribeData.NumTribeDinos"); }
	TSet<unsigned __int64, DefaultKeyFuncs<unsigned __int64, 0>, FDefaultSetAllocator>& MembersPlayerDataIDSet_ServerField() { return *GetNativePointerField<TSet<unsigned __int64, DefaultKeyFuncs<unsigned __int64, 0>, FDefaultSetAllocator>*>(this, "FTribeData.MembersPlayerDataIDSet_Server"); }
	TArray<FTrackedActorPlusInfoStruct, TSizedDefaultAllocator<32>>& CachedTeamTameList_UpdatedOnIntervalField() { return *GetNativePointerField<TArray<FTrackedActorPlusInfoStruct, TSizedDefaultAllocator<32>>*>(this, "FTribeData.CachedTeamTameList_UpdatedOnInterval"); }
	long double& LastNetworkTimeUpdatedCachedTeamTameListField() { return *GetNativePointerField<long double*>(this, "FTribeData.LastNetworkTimeUpdatedCachedTeamTameList"); }
	FTeamPingData& RallyPointDataField() { return *GetNativePointerField<FTeamPingData*>(this, "FTribeData.RallyPointData"); }
	bool& bHaveRallyPointDataField() { return *GetNativePointerField<bool*>(this, "FTribeData.bHaveRallyPointData"); }

	// Functions

	bool IsTribeWarActive(int TribeID, UWorld* ForWorld, bool bIncludeUnstarted) { return NativeCall<bool, int, UWorld*, bool>(this, "FTribeData.IsTribeWarActive(int,UWorld*,bool)", TribeID, ForWorld, bIncludeUnstarted); }
	FTribeAlliance* FindTribeAlliance(unsigned int AllianceID) { return NativeCall<FTribeAlliance*, unsigned int>(this, "FTribeData.FindTribeAlliance(unsignedint)", AllianceID); }
	bool IsTribeAlliedWith(unsigned int OtherTribeID) { return NativeCall<bool, unsigned int>(this, "FTribeData.IsTribeAlliedWith(unsignedint)", OtherTribeID); }
	bool GetTribeRankGroupForPlayer(unsigned int PlayerDataID, FTribeRankGroup* outRankGroup) { return NativeCall<bool, unsigned int, FTribeRankGroup*>(this, "FTribeData.GetTribeRankGroupForPlayer(unsignedint,FTribeRankGroup&)", PlayerDataID, outRankGroup); }
	long double GetSecondsSinceLastNameChange(UObject* WorldContextObject) { return NativeCall<long double, UObject*>(this, "FTribeData.GetSecondsSinceLastNameChange(UObject*)", WorldContextObject); }
	int GetDefaultRankGroupIndex() { return NativeCall<int>(this, "FTribeData.GetDefaultRankGroupIndex()"); }
	FTribeData* operator=(FTribeData* __that) { return NativeCall<FTribeData*, FTribeData*>(this, "FTribeData.operator=(FTribeData&)", __that); }
	static UScriptStruct* StaticStruct() { return NativeCall<UScriptStruct*>(nullptr, "FTribeData.StaticStruct()"); }
};

struct UBlueprintFunctionLibrary
{

};

struct UGameplayStatics : UBlueprintFunctionLibrary
{
	// Fields


	  // Bitfields


	  // Functions

	static void PlaySoundAtLocation(const UObject* WorldContextObject, USoundBase* Sound, UE::Math::TVector<double>* Location, float VolumeMultiplier) { NativeCall<void, const UObject*, USoundBase*, UE::Math::TVector<double>*, float>(nullptr, "UGameplayStatics.PlaySoundAtLocation(UObject*,USoundBase*,UE::Math::TVector<double>&,float)", WorldContextObject, Sound, Location, VolumeMultiplier); }
	static UAudioComponent* SpawnSoundAttached(USoundBase* Sound, USceneComponent* AttachToComponent, FName AttachPointName, UE::Math::TVector<double>* Location, EAttachLocation::Type LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, USoundAttenuation* AttenuationSettings) { return NativeCall<UAudioComponent*, USoundBase*, USceneComponent*, FName, UE::Math::TVector<double>*, EAttachLocation::Type, bool, float, float, float, USoundAttenuation*>(nullptr, "UGameplayStatics.SpawnSoundAttached(USoundBase*,USceneComponent*,FName,UE::Math::TVector<double>&,EAttachLocation::Type,bool,float,float,float,USoundAttenuation*)", Sound, AttachToComponent, AttachPointName, Location, LocationType, bStopWhenAttachedToDestroyed, VolumeMultiplier, PitchMultiplier, StartTime, AttenuationSettings); }
	static UClass* GetPrivateStaticClass() { return NativeCall<UClass*>(nullptr, "UGameplayStatics.GetPrivateStaticClass()"); }
	static void StaticRegisterNativesUGameplayStatics() { NativeCall<void>(nullptr, "UGameplayStatics.StaticRegisterNativesUGameplayStatics()"); }
	//static UGameInstance* GetGameInstance(const UObject* WorldContextObject, ELogVerbosity::Type a2, FName a3) { return NativeCall<UGameInstance*, const UObject*, ELogVerbosity::Type, FName>(nullptr, "UGameplayStatics.GetGameInstance(UObject*,ELogVerbosity::Type,FName)", WorldContextObject, a2, a3); }
	static APlayerController* GetPlayerController(const UObject* WorldContextObject, int PlayerIndex, FName a3) { return NativeCall<APlayerController*, const UObject*, int, FName>(nullptr, "UGameplayStatics.GetPlayerController(UObject*,int,FName)", WorldContextObject, PlayerIndex, a3); }
	static ACharacter* GetPlayerCharacter(const UObject* WorldContextObject, int PlayerIndex, FName a3) { return NativeCall<ACharacter*, const UObject*, int, FName>(nullptr, "UGameplayStatics.GetPlayerCharacter(UObject*,int,FName)", WorldContextObject, PlayerIndex, a3); }
	//static AGameStateBase* GetGameState(const UObject* WorldContextObject, ELogVerbosity::Type a2, FName a3) { return NativeCall<AGameStateBase*, const UObject*, ELogVerbosity::Type, FName>(nullptr, "UGameplayStatics.GetGameState(UObject*,ELogVerbosity::Type,FName)", WorldContextObject, a2, a3); }
	static bool ApplyRadialDamage(const UObject* WorldContextObject, float BaseDamage, const UE::Math::TVector<double>* Origin, float DamageRadius, TSubclassOf<UDamageType> DamageTypeClass, const TArray<AActor*, TSizedDefaultAllocator<32> >* IgnoreActors, AActor* DamageCauser, AController* InstigatedByController, bool bDoFullDamage, ECollisionChannel DamagePreventionChannel, float Impulse) { return NativeCall<bool, const UObject*, float, const UE::Math::TVector<double>*, float, TSubclassOf<UDamageType>, const TArray<AActor*, TSizedDefaultAllocator<32> >*, AActor*, AController*, bool, ECollisionChannel, float>(nullptr, "UGameplayStatics.ApplyRadialDamage(UObject*,float,UE::Math::TVector<double>&,float,TSubclassOf<UDamageType>,TArray<AActor*,TSizedDefaultAllocator<32>>&,AActor*,AController*,bool,ECollisionChannel,float)", WorldContextObject, BaseDamage, Origin, DamageRadius, DamageTypeClass, IgnoreActors, DamageCauser, InstigatedByController, bDoFullDamage, DamagePreventionChannel, Impulse); }
	static bool ApplyRadialDamageIgnoreDamageActors(const UObject* WorldContextObject, float BaseDamage, const UE::Math::TVector<double>* Origin, float DamageRadius, TSubclassOf<UDamageType> DamageTypeClass, const TArray<AActor*, TSizedDefaultAllocator<32> >* IgnoreActors, const TArray<AActor*, TSizedDefaultAllocator<32> >* IgnoreDamageActors, AActor* DamageCauser, AController* InstigatedByController, bool bDoFullDamage, ECollisionChannel DamagePreventionChannel, float Impulse, float FallOff) { return NativeCall<bool, const UObject*, float, const UE::Math::TVector<double>*, float, TSubclassOf<UDamageType>, const TArray<AActor*, TSizedDefaultAllocator<32> >*, const TArray<AActor*, TSizedDefaultAllocator<32> >*, AActor*, AController*, bool, ECollisionChannel, float, float>(nullptr, "UGameplayStatics.ApplyRadialDamageIgnoreDamageActors(UObject*,float,UE::Math::TVector<double>&,float,TSubclassOf<UDamageType>,TArray<AActor*,TSizedDefaultAllocator<32>>&,TArray<AActor*,TSizedDefaultAllocator<32>>&,AActor*,AController*,bool,ECollisionChannel,float,float)", WorldContextObject, BaseDamage, Origin, DamageRadius, DamageTypeClass, IgnoreActors, IgnoreDamageActors, DamageCauser, InstigatedByController, bDoFullDamage, DamagePreventionChannel, Impulse, FallOff); }
	static bool ApplyRadialDamageWithFalloff(const UObject* WorldContextObject, float BaseDamage, float MinimumDamage, const UE::Math::TVector<double>* Origin, float DamageInnerRadius, float DamageOuterRadius, float DamageFalloff, TSubclassOf<UDamageType> DamageTypeClass, const TArray<AActor*, TSizedDefaultAllocator<32> >* IgnoreActors, AActor* DamageCauser, AController* InstigatedByController, ECollisionChannel DamagePreventionChannel, float Impulse, TArray<AActor*, TSizedDefaultAllocator<32> >* IgnoreDamageActors, int NumAdditionalAttempts) { return NativeCall<bool, const UObject*, float, float, const UE::Math::TVector<double>*, float, float, float, TSubclassOf<UDamageType>, const TArray<AActor*, TSizedDefaultAllocator<32> >*, AActor*, AController*, ECollisionChannel, float, TArray<AActor*, TSizedDefaultAllocator<32> >*, int>(nullptr, "UGameplayStatics.ApplyRadialDamageWithFalloff(UObject*,float,float,UE::Math::TVector<double>&,float,float,float,TSubclassOf<UDamageType>,TArray<AActor*,TSizedDefaultAllocator<32>>&,AActor*,AController*,ECollisionChannel,float,TArray<AActor*,TSizedDefaultAllocator<32>>&,int)", WorldContextObject, BaseDamage, MinimumDamage, Origin, DamageInnerRadius, DamageOuterRadius, DamageFalloff, DamageTypeClass, IgnoreActors, DamageCauser, InstigatedByController, DamagePreventionChannel, Impulse, IgnoreDamageActors, NumAdditionalAttempts); }
	static float ApplyPointDamage(AActor* DamagedActor, float BaseDamage, const UE::Math::TVector<double>* HitFromDirection, const FHitResult* HitInfo, AController* EventInstigator, AActor* DamageCauser, TSubclassOf<UDamageType> DamageTypeClass, float Impulse, bool bForceCollisionCheck, ECollisionChannel ForceCollisionCheckTraceChannel) { return NativeCall<float, AActor*, float, const UE::Math::TVector<double>*, const FHitResult*, AController*, AActor*, TSubclassOf<UDamageType>, float, bool, ECollisionChannel>(nullptr, "UGameplayStatics.ApplyPointDamage(AActor*,float,UE::Math::TVector<double>&,FHitResult*,AController*,AActor*,TSubclassOf<UDamageType>,float,bool,ECollisionChannel)", DamagedActor, BaseDamage, HitFromDirection, HitInfo, EventInstigator, DamageCauser, DamageTypeClass, Impulse, bForceCollisionCheck, ForceCollisionCheckTraceChannel); }
	static float ApplyDamage(AActor* DamagedActor, float BaseDamage, AController* EventInstigator, AActor* DamageCauser, TSubclassOf<UDamageType> DamageTypeClass, float Impulse) { return NativeCall<float, AActor*, float, AController*, AActor*, TSubclassOf<UDamageType>, float>(nullptr, "UGameplayStatics.ApplyDamage(AActor*,float,AController*,AActor*,TSubclassOf<UDamageType>,float)", DamagedActor, BaseDamage, EventInstigator, DamageCauser, DamageTypeClass, Impulse); }
	static AActor* BeginDeferredActorSpawnFromClass(const UObject* WorldContextObject, TSubclassOf<AActor> ActorClass, const UE::Math::TTransform<double>* SpawnTransform, ESpawnActorCollisionHandlingMethod CollisionHandlingOverride, AActor* Owner, ESpawnActorScaleMethod TransformScaleMethod) { return NativeCall<AActor*, const UObject*, TSubclassOf<AActor>, const UE::Math::TTransform<double>*, ESpawnActorCollisionHandlingMethod, AActor*, ESpawnActorScaleMethod>(nullptr, "UGameplayStatics.BeginDeferredActorSpawnFromClass(UObject*,TSubclassOf<AActor>,UE::Math::TTransform<double>&,ESpawnActorCollisionHandlingMethod,AActor*,ESpawnActorScaleMethod)", WorldContextObject, ActorClass, SpawnTransform, CollisionHandlingOverride, Owner, TransformScaleMethod); }
	static void LoadStreamLevel(const UObject* WorldContextObject, FName LevelName, FName bMakeVisibleAfterLoad, bool bShouldBlockOnLoad, FLatentActionInfo* LatentInfo) { NativeCall<void, const UObject*, FName, FName, bool, FLatentActionInfo*>(nullptr, "UGameplayStatics.LoadStreamLevel(UObject*,FName,FName,bool,FLatentActionInfo*)", WorldContextObject, LevelName, bMakeVisibleAfterLoad, bShouldBlockOnLoad, LatentInfo); }
	static void LoadStreamLevelBySoftObjectPtr(const UObject* WorldContextObject, const TSoftObjectPtr<UWorld>* Level, bool bMakeVisibleAfterLoad, bool bShouldBlockOnLoad, FLatentActionInfo* LatentInfo) { NativeCall<void, const UObject*, const TSoftObjectPtr<UWorld>*, bool, bool, FLatentActionInfo*>(nullptr, "UGameplayStatics.LoadStreamLevelBySoftObjectPtr(UObject*,TSoftObjectPtr<UWorld>&,bool,bool,FLatentActionInfo*)", WorldContextObject, Level, bMakeVisibleAfterLoad, bShouldBlockOnLoad, LatentInfo); }
	static void UnloadStreamLevel(const UObject* WorldContextObject, FName LevelName, FLatentActionInfo* LatentInfo, bool bShouldBlockOnUnload) { NativeCall<void, const UObject*, FName, FLatentActionInfo*, bool>(nullptr, "UGameplayStatics.UnloadStreamLevel(UObject*,FName,FLatentActionInfo*,bool)", WorldContextObject, LevelName, LatentInfo, bShouldBlockOnUnload); }
	static void UnloadStreamLevelBySoftObjectPtr(const UObject* WorldContextObject, const TSoftObjectPtr<UWorld>* Level, FLatentActionInfo* LatentInfo, bool bShouldBlockOnUnload) { NativeCall<void, const UObject*, const TSoftObjectPtr<UWorld>*, FLatentActionInfo*, bool>(nullptr, "UGameplayStatics.UnloadStreamLevelBySoftObjectPtr(UObject*,TSoftObjectPtr<UWorld>&,FLatentActionInfo*,bool)", WorldContextObject, Level, LatentInfo, bShouldBlockOnUnload); }
	static void OpenLevel(const UObject* WorldContextObject, FName LevelName, FName bAbsolute, FString* Options) { NativeCall<void, const UObject*, FName, FName, FString*>(nullptr, "UGameplayStatics.OpenLevel(UObject*,FName,FName,FString&)", WorldContextObject, LevelName, bAbsolute, Options); }
	static void OpenLevelBySoftObjectPtr(const UObject* WorldContextObject, const TSoftObjectPtr<UWorld>* Level, bool bAbsolute, FString* Options) { NativeCall<void, const UObject*, const TSoftObjectPtr<UWorld>*, bool, FString*>(nullptr, "UGameplayStatics.OpenLevelBySoftObjectPtr(UObject*,TSoftObjectPtr<UWorld>&,bool,FString&)", WorldContextObject, Level, bAbsolute, Options); }
	static FString* GetCurrentLevelName(FString* result, const UObject* WorldContextObject, FName bRemovePrefixString) { return NativeCall<FString*, FString*, const UObject*, FName>(nullptr, "UGameplayStatics.GetCurrentLevelName(FString&,UObject*,FName)", result, WorldContextObject, bRemovePrefixString); }
	static AActor* GetActorOfClass(const UObject* WorldContextObject, TSubclassOf<AActor> ActorClass) { return NativeCall<AActor*, const UObject*, TSubclassOf<AActor>>(nullptr, "UGameplayStatics.GetActorOfClass(UObject*,TSubclassOf<AActor>)", WorldContextObject, ActorClass); }
	static void GetAllActorsOfClass(const UObject* WorldContextObject, TSubclassOf<AActor> ActorClass, TArray<AActor*, TSizedDefaultAllocator<32> >* OutActors) { NativeCall<void, const UObject*, TSubclassOf<AActor>, TArray<AActor*, TSizedDefaultAllocator<32> >*>(nullptr, "UGameplayStatics.GetAllActorsOfClass(UObject*,TSubclassOf<AActor>,TArray<AActor*,TSizedDefaultAllocator<32>>&)", WorldContextObject, ActorClass, OutActors); }
	static void GetAllActorsWithInterface(const UObject* WorldContextObject, TSubclassOf<UInterface> Interface, TArray<AActor*, TSizedDefaultAllocator<32> >* OutActors) { NativeCall<void, const UObject*, TSubclassOf<UInterface>, TArray<AActor*, TSizedDefaultAllocator<32> >*>(nullptr, "UGameplayStatics.GetAllActorsWithInterface(UObject*,TSubclassOf<UInterface>,TArray<AActor*,TSizedDefaultAllocator<32>>&)", WorldContextObject, Interface, OutActors); }
	static void GetAllActorsWithTag(const UObject* WorldContextObject, FName Tag, TArray<AActor*, TSizedDefaultAllocator<32> >* OutActors) { NativeCall<void, const UObject*, FName, TArray<AActor*, TSizedDefaultAllocator<32> >*>(nullptr, "UGameplayStatics.GetAllActorsWithTag(UObject*,FName,TArray<AActor*,TSizedDefaultAllocator<32>>&)", WorldContextObject, Tag, OutActors); }
	static void GetAllActorsOfClassWithTag(const UObject* WorldContextObject, TSubclassOf<AActor> ActorClass, FName Tag, TArray<AActor*, TSizedDefaultAllocator<32> >* OutActors) { NativeCall<void, const UObject*, TSubclassOf<AActor>, FName, TArray<AActor*, TSizedDefaultAllocator<32> >*>(nullptr, "UGameplayStatics.GetAllActorsOfClassWithTag(UObject*,TSubclassOf<AActor>,FName,TArray<AActor*,TSizedDefaultAllocator<32>>&)", WorldContextObject, ActorClass, Tag, OutActors); }
	static void BreakHitResult(const FHitResult* Hit, bool* bBlockingHit, bool* bInitialOverlap, float* Time, float* Distance, UE::Math::TVector<double>* Location, UE::Math::TVector<double>* ImpactPoint, UE::Math::TVector<double>* Normal, UE::Math::TVector<double>* ImpactNormal, UPhysicalMaterial** PhysMat, AActor** HitActor, UPrimitiveComponent** HitComponent, FName* HitBoneName, FName* BoneName, int* HitItem, int* ElementIndex, int* FaceIndex, UE::Math::TVector<double>* TraceStart, UE::Math::TVector<double>* TraceEnd) { NativeCall<void, const FHitResult*, bool*, bool*, float*, float*, UE::Math::TVector<double>*, UE::Math::TVector<double>*, UE::Math::TVector<double>*, UE::Math::TVector<double>*, UPhysicalMaterial**, AActor**, UPrimitiveComponent**, FName*, FName*, int*, int*, int*, UE::Math::TVector<double>*, UE::Math::TVector<double>*>(nullptr, "UGameplayStatics.BreakHitResult(FHitResult*,bool*,bool*,float*,float*,UE::Math::TVector<double>&,UE::Math::TVector<double>&,UE::Math::TVector<double>&,UE::Math::TVector<double>&,UPhysicalMaterial*&,AActor*&,UPrimitiveComponent*&,FName*,FName*,int*,int*,int*,UE::Math::TVector<double>&,UE::Math::TVector<double>&)", Hit, bBlockingHit, bInitialOverlap, Time, Distance, Location, ImpactPoint, Normal, ImpactNormal, PhysMat, HitActor, HitComponent, HitBoneName, BoneName, HitItem, ElementIndex, FaceIndex, TraceStart, TraceEnd); }
	static bool FindCollisionUV(const FHitResult* Hit, int UVChannel, UE::Math::TVector2<double>* UV) { return NativeCall<bool, const FHitResult*, int, UE::Math::TVector2<double>*>(nullptr, "UGameplayStatics.FindCollisionUV(FHitResult*,int,UE::Math::TVector2<double>&)", Hit, UVChannel, UV); }
	void PlaySound2D(USoundBase* Sound, UE::Math::TVector<double>* Location, float VolumeMultiplier) { NativeCall<void, USoundBase*, UE::Math::TVector<double>*, float>(this, "UGameplayStatics.PlaySound2D(USoundBase*,UE::Math::TVector<double>&,float)", Sound, Location, VolumeMultiplier); }
	//static UAudioComponent* CreateSound2D(const UObject* WorldContextObject, USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier) { return NativeCall<UAudioComponent*, const UObject*, USoundBase*, float, float>(nullptr, "UGameplayStatics.CreateSound2D(UObject*,USoundBase*,float,float)", WorldContextObject, Sound, VolumeMultiplier, PitchMultiplier); }
	//static UAudioComponent* SpawnSoundAttached(USoundBase* Sound, USceneComponent* AttachToComponent, FName AttachPointName, UE::Math::TVector<double>* Location, UE::Math::TRotator<double>* Rotation, EAttachLocation::Type LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, USoundAttenuation* AttenuationSettings, USoundConcurrency* ConcurrencySettings, bool bAutoDestroy, bool bAlwaysPlay) { return NativeCall<UAudioComponent*, USoundBase*, USceneComponent*, FName, UE::Math::TVector<double>*, UE::Math::TRotator<double>*, EAttachLocation::Type, bool, float, float, float, USoundAttenuation*, USoundConcurrency*, bool, bool>(nullptr, "UGameplayStatics.SpawnSoundAttached(USoundBase*,USceneComponent*,FName,UE::Math::TVector<double>&,UE::Math::TRotator<double>&,EAttachLocation::Type,bool,float,float,float,USoundAttenuation*,USoundConcurrency*,bool,bool)", Sound, AttachToComponent, AttachPointName, Location, Rotation, LocationType, bStopWhenAttachedToDestroyed, VolumeMultiplier, PitchMultiplier, StartTime, AttenuationSettings, ConcurrencySettings, bAutoDestroy, bAlwaysPlay); }
	static void PrimeSound(USoundBase* InSound) { NativeCall<void, USoundBase*>(nullptr, "UGameplayStatics.PrimeSound(USoundBase*)", InSound); }
	static void PrimeAllSoundsInSoundClass(USoundClass* InSoundClass) { NativeCall<void, USoundClass*>(nullptr, "UGameplayStatics.PrimeAllSoundsInSoundClass(USoundClass*)", InSoundClass); }
	static void UnRetainAllSoundsInSoundClass(USoundClass* InSoundClass) { NativeCall<void, USoundClass*>(nullptr, "UGameplayStatics.UnRetainAllSoundsInSoundClass(USoundClass*)", InSoundClass); }
	static USceneComponent* SpawnDecalAttached(UMaterialInterface* DecalMaterial, UE::Math::TVector<double>* DecalSize, USceneComponent* AttachToComponent, FName AttachPointName, UE::Math::TVector<double>* Location, UE::Math::TRotator<double>* Rotation, EAttachLocation::Type LocationType, float LifeSpan) { return NativeCall<USceneComponent*, UMaterialInterface*, UE::Math::TVector<double>*, USceneComponent*, FName, UE::Math::TVector<double>*, UE::Math::TRotator<double>*, EAttachLocation::Type, float>(nullptr, "UGameplayStatics.SpawnDecalAttached(UMaterialInterface*,UE::Math::TVector<double>&,USceneComponent*,FName,UE::Math::TVector<double>&,UE::Math::TRotator<double>&,EAttachLocation::Type,float)", DecalMaterial, DecalSize, AttachToComponent, AttachPointName, Location, Rotation, LocationType, LifeSpan); }
	//static USaveGame* CreateSaveGameObject(TSubclassOf<USaveGame> SaveGameClass) { return NativeCall<USaveGame*, TSubclassOf<USaveGame>>(nullptr, "UGameplayStatics.CreateSaveGameObject(TSubclassOf<USaveGame>)", SaveGameClass); }
	//static bool SaveGameToMemory(USaveGame* SaveGameObject, TArray<unsigned char, TSizedDefaultAllocator<32> >* OutSaveData) { return NativeCall<bool, USaveGame*, TArray<unsigned char, TSizedDefaultAllocator<32> >*>(nullptr, "UGameplayStatics.SaveGameToMemory(USaveGame*,TArray<unsignedchar,TSizedDefaultAllocator<32>>&)", SaveGameObject, OutSaveData); }
	//static void AsyncSaveGameToSlot(USaveGame* SaveGameObject, const FString* SlotName, const int UserIndex, TDelegate<void __cdecl(FString const&, int, bool), FDefaultDelegateUserPolicy>* SavedDelegate) { NativeCall<void, USaveGame*, const FString*, const int, TDelegate<void __cdecl(FString const&, int, bool), FDefaultDelegateUserPolicy>*>(nullptr, "UGameplayStatics.AsyncSaveGameToSlot(USaveGame*,FString&,int,TDelegate<void__cdecl(FString&,int,bool),FDefaultDelegateUserPolicy>&)", SaveGameObject, SlotName, UserIndex, SavedDelegate); }
	//static bool SaveGameToSlot(USaveGame* SaveGameObject, const FString* SlotName, const int UserIndex) { return NativeCall<bool, USaveGame*, const FString*, const int>(nullptr, "UGameplayStatics.SaveGameToSlot(USaveGame*,FString&,int)", //SaveGameObject, SlotName, UserIndex); }
	//static USaveGame* LoadGameFromMemory(const TArray<unsigned char, TSizedDefaultAllocator<32> >* InSaveData) { return NativeCall<USaveGame*, const TArray<unsigned char, TSizedDefaultAllocator<32> >*>(nullptr, "UGameplayStatics.LoadGameFromMemory(TArray<unsignedchar,TSizedDefaultAllocator<32>>&)", InSaveData); }
	//static void AsyncLoadGameFromSlot(const FString* SlotName, const int UserIndex, TDelegate<void __cdecl(FString const&, int, USaveGame*), FDefaultDelegateUserPolicy>* LoadedDelegate) { NativeCall<void, const FString*, const int, TDelegate<void __cdecl(FString const&, int, USaveGame*), FDefaultDelegateUserPolicy>*>(nullptr, "UGameplayStatics.AsyncLoadGameFromSlot(FString&,int,TDelegate<void__cdecl(FString&,int,USaveGame*),FDefaultDelegateUserPolicy>&)", SlotName, UserIndex, LoadedDelegate); }
	//static USaveGame* LoadGameFromSlot(const FString* SlotName, const int UserIndex) { return NativeCall<USaveGame*, const FString*, const int>(nullptr, "UGameplayStatics.LoadGameFromSlot(FString&,int)", SlotName, UserIndex); }
	static long double GetWorldDeltaSeconds(const UObject* WorldContextObject, ELogVerbosity::Type a2, FName a3) { return NativeCall<long double, const UObject*, ELogVerbosity::Type, FName>(nullptr, "UGameplayStatics.GetWorldDeltaSeconds(UObject*,ELogVerbosity::Type,FName)", WorldContextObject, a2, a3); }
	//static bool SuggestProjectileVelocity(const UObject* WorldContextObject, UE::Math::TVector<double>* OutTossVelocity, UE::Math::TVector<double>* Start, UE::Math::TVector<double>* End, float TossSpeed, bool bFavorHighArc, float CollisionRadius, float OverrideGravityZ, ESuggestProjVelocityTraceOption::Type TraceOption, const FCollisionResponseParams* ResponseParam, const TArray<AActor*, TSizedDefaultAllocator<32> >* ActorsToIgnore, bool bDrawDebug) { return NativeCall<bool, const UObject*, UE::Math::TVector<double>*, UE::Math::TVector<double>*, UE::Math::TVector<double>*, float, bool, float, float, ESuggestProjVelocityTraceOption::Type, const FCollisionResponseParams*, const TArray<AActor*, TSizedDefaultAllocator<32> >*, bool>(nullptr, "UGameplayStatics.SuggestProjectileVelocity(UObject*,UE::Math::TVector<double>&,UE::Math::TVector<double>&,UE::Math::TVector<double>&,float,bool,float,float,ESuggestProjVelocityTraceOption::Type,FCollisionResponseParams*,TArray<AActor*,TSizedDefaultAllocator<32>>&,bool)", WorldContextObject, OutTossVelocity, Start, End, TossSpeed, bFavorHighArc, CollisionRadius, OverrideGravityZ, TraceOption, ResponseParam, ActorsToIgnore, bDrawDebug); }
	//static bool PredictProjectilePath(const UObject* WorldContextObject, const FPredictProjectilePathParams* PredictParams, FPredictProjectilePathResult* PredictResult) { return NativeCall<bool, const UObject*, const FPredictProjectilePathParams*, FPredictProjectilePathResult*>(nullptr, "UGameplayStatics.PredictProjectilePath(UObject*,FPredictProjectilePathParams*,FPredictProjectilePathResult*)", WorldContextObject, PredictParams, PredictResult); }
	//static _BOOL8 Blueprint_PredictProjectilePath_ByObjectType(const UObject* WorldContextObject, FHitResult* OutHit, TArray<UE::Math::TVector<double>, TSizedDefaultAllocator<32> >* OutPathPositions, UE::Math::TVector<double>* OutLastTraceDestination, UE::Math::TVector<double>* StartPos, UE::Math::TVector<double>* LaunchVelocity, bool bTracePath, float ProjectileRadius, const TArray<TEnumAsByte<enum EObjectTypeQuery>, TSizedDefaultAllocator<32> >* ObjectTypes, bool bTraceComplex, const TArray<AActor*, TSizedDefaultAllocator<32> >* ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, float DrawDebugTime, float SimFrequency, float MaxSimTime, float OverrideGravityZ) { return NativeCall<_BOOL8, const UObject*, FHitResult*, TArray<UE::Math::TVector<double>, TSizedDefaultAllocator<32> >*, UE::Math::TVector<double>*, UE::Math::TVector<double>*, UE::Math::TVector<double>*, bool, float, const TArray<TEnumAsByte<enum EObjectTypeQuery>, TSizedDefaultAllocator<32> >*, bool, const TArray<AActor*, TSizedDefaultAllocator<32> >*, EDrawDebugTrace::Type, float, float, float, float>(nullptr, "UGameplayStatics.Blueprint_PredictProjectilePath_ByObjectType(UObject*,FHitResult*,TArray<UE::Math::TVector<double>,TSizedDefaultAllocator<32>>&,UE::Math::TVector<double>&,UE::Math::TVector<double>&,UE::Math::TVector<double>&,bool,float,TArray<TEnumAsByte<EObjectTypeQuery>,TSizedDefaultAllocator<32>>&,bool,TArray<AActor*,TSizedDefaultAllocator<32>>&,EDrawDebugTrace::Type,float,float,float,float)", WorldContextObject, OutHit, OutPathPositions, OutLastTraceDestination, StartPos, LaunchVelocity, bTracePath, ProjectileRadius, ObjectTypes, bTraceComplex, ActorsToIgnore, DrawDebugType, DrawDebugTime, SimFrequency, MaxSimTime, OverrideGravityZ); }
	//static _BOOL8 Blueprint_PredictProjectilePath_ByTraceChannel(const UObject* WorldContextObject, FHitResult* OutHit, TArray<UE::Math::TVector<double>, TSizedDefaultAllocator<32> >* OutPathPositions, UE::Math::TVector<double>* OutLastTraceDestination, UE::Math::TVector<double>* StartPos, UE::Math::TVector<double>* LaunchVelocity, bool bTracePath, float ProjectileRadius, TEnumAsByte<enum ECollisionChannel> TraceChannel, bool bTraceComplex, const TArray<AActor*, TSizedDefaultAllocator<32> >* ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, float DrawDebugTime, float SimFrequency, float MaxSimTime, float OverrideGravityZ) { return NativeCall<_BOOL8, const UObject*, FHitResult*, TArray<UE::Math::TVector<double>, TSizedDefaultAllocator<32> >*, UE::Math::TVector<double>*, UE::Math::TVector<double>*, UE::Math::TVector<double>*, bool, float, TEnumAsByte<enum ECollisionChannel>, bool, const TArray<AActor*, TSizedDefaultAllocator<32> >*, EDrawDebugTrace::Type, float, float, float, float>(nullptr, "UGameplayStatics.Blueprint_PredictProjectilePath_ByTraceChannel(UObject*,FHitResult*,TArray<UE::Math::TVector<double>,TSizedDefaultAllocator<32>>&,UE::Math::TVector<double>&,UE::Math::TVector<double>&,UE::Math::TVector<double>&,bool,float,TEnumAsByte<ECollisionChannel>,bool,TArray<AActor*,TSizedDefaultAllocator<32>>&,EDrawDebugTrace::Type,float,float,float,float)", WorldContextObject, OutHit, OutPathPositions, OutLastTraceDestination, StartPos, LaunchVelocity, bTracePath, ProjectileRadius, TraceChannel, bTraceComplex, ActorsToIgnore, DrawDebugType, DrawDebugTime, SimFrequency, MaxSimTime, OverrideGravityZ); }
	static __int64 GrassOverlappingSphereCount(const UObject* WorldContextObject, const UStaticMesh* Mesh, UE::Math::TVector<double>* CenterPosition, float Radius) { return NativeCall<__int64, const UObject*, const UStaticMesh*, UE::Math::TVector<double>*, float>(nullptr, "UGameplayStatics.GrassOverlappingSphereCount(UObject*,UStaticMesh*,UE::Math::TVector<double>&,float)", WorldContextObject, Mesh, CenterPosition, Radius); }
	static bool DeprojectScreenToWorld(const APlayerController* Player, const UE::Math::TVector2<double>* ScreenPosition, UE::Math::TVector<double>* WorldPosition, UE::Math::TVector<double>* WorldDirection) { return NativeCall<bool, const APlayerController*, const UE::Math::TVector2<double>*, UE::Math::TVector<double>*, UE::Math::TVector<double>*>(nullptr, "UGameplayStatics.DeprojectScreenToWorld(APlayerController*,UE::Math::TVector2<double>&,UE::Math::TVector<double>&,UE::Math::TVector<double>&)", Player, ScreenPosition, WorldPosition, WorldDirection); }
	//static bool DeprojectSceneCaptureToWorld(const ASceneCapture2D* SceneCapture2D, const UE::Math::TVector2<double>* TargetUV, UE::Math::TVector<double>* WorldPosition, UE::Math::TVector<double>* WorldDirection) { return NativeCall<bool, const ASceneCapture2D*, const UE::Math::TVector2<double>*, UE::Math::TVector<double>*, UE::Math::TVector<double>*>(nullptr, "UGameplayStatics.DeprojectSceneCaptureToWorld(ASceneCapture2D*,UE::Math::TVector2<double>&,UE::Math::TVector<double>&,UE::Math::TVector<double>&)", SceneCapture2D, TargetUV, WorldPosition, WorldDirection); }
	static bool ProjectWorldToScreen(const APlayerController* Player, const UE::Math::TVector<double>* WorldPosition, UE::Math::TVector2<double>* ScreenPosition, bool bPlayerViewportRelative) { return NativeCall<bool, const APlayerController*, const UE::Math::TVector<double>*, UE::Math::TVector2<double>*, bool>(nullptr, "UGameplayStatics.ProjectWorldToScreen(APlayerController*,UE::Math::TVector<double>&,UE::Math::TVector2<double>&,bool)", Player, WorldPosition, ScreenPosition, bPlayerViewportRelative); }
	static void CalculateViewProjectionMatricesFromMinimalView(const FMinimalViewInfo* MinimalViewInfo, const TOptional<UE::Math::TMatrix<double> >* CustomProjectionMatrix, UE::Math::TMatrix<double>* OutViewMatrix, UE::Math::TMatrix<double>* OutProjectionMatrix, UE::Math::TMatrix<double>* OutViewProjectionMatrix) { NativeCall<void, const FMinimalViewInfo*, const TOptional<UE::Math::TMatrix<double> >*, UE::Math::TMatrix<double>*, UE::Math::TMatrix<double>*, UE::Math::TMatrix<double>*>(nullptr, "UGameplayStatics.CalculateViewProjectionMatricesFromMinimalView(FMinimalViewInfo*,TOptional<UE::Math::TMatrix<double>>&,UE::Math::TMatrix<double>&,UE::Math::TMatrix<double>&,UE::Math::TMatrix<double>&)", MinimalViewInfo, CustomProjectionMatrix, OutViewMatrix, OutProjectionMatrix, OutViewProjectionMatrix); }
	static bool GrabOption(FString* Options, FString* Result) { return NativeCall<bool, FString*, FString*>(nullptr, "UGameplayStatics.GrabOption(FString&,FString&)", Options, Result); }
	static void GetKeyValue(const FString* Pair, FString* Key, FString* Value) { NativeCall<void, const FString*, FString*, FString*>(nullptr, "UGameplayStatics.GetKeyValue(FString&,FString&,FString&)", Pair, Key, Value); }
	static FString* ParseOption(FString* result, FString* Options, const FString* Key) { return NativeCall<FString*, FString*, FString*, const FString*>(nullptr, "UGameplayStatics.ParseOption(FString&,FString&,FString&)", result, Options, Key); }
	static bool HasOption(FString* Options, const FString* Key) { return NativeCall<bool, FString*, const FString*>(nullptr, "UGameplayStatics.HasOption(FString&,FString&)", Options, Key); }
};

struct UKismetSystemLibrary
{
	// Functions

	//static FString* MakeLiteralString(FString* result, FString* Value) { return NativeCall<FString*, FString*, FString*>(nullptr, "UKismetSystemLibrary.MakeLiteralString", result, Value); }
	//static FString* GetDisplayName(FString* result, UObject* Object) { return NativeCall<FString*, FString*, UObject*>(nullptr, "UKismetSystemLibrary.GetDisplayName", result, Object); }
	//static FString* GetClassDisplayName(FString* result, UClass* Class) { return NativeCall<FString*, FString*, UClass*>(nullptr, "UKismetSystemLibrary.GetClassDisplayName", result, Class); }
	//static FString* GetEngineVersion(FString* result) { return NativeCall<FString*, FString*>(nullptr, "UKismetSystemLibrary.GetEngineVersion", result); }
	//static FString* GetGameName(FString* result) { return NativeCall<FString*, FString*>(nullptr, "UKismetSystemLibrary.GetGameName", result); }
	//static FString* GetPlatformUserName(FString* result) { return NativeCall<FString*, FString*>(nullptr, "UKismetSystemLibrary.GetPlatformUserName", result); }
	//static bool DoesImplementInterface(UObject* TestObject, TSubclassOf<UInterface> Interface) { return NativeCall<bool, UObject*, TSubclassOf<UInterface>>(nullptr, "UKismetSystemLibrary.DoesImplementInterface", TestObject, Interface); }
	static FString* GetUniqueDeviceId(FString* result) { return NativeCall<FString*, FString*>(nullptr, "UKismetSystemLibrary.GetUniqueDeviceId", result); }
	//static FText* MakeLiteralText(FText* result, FText Value) { return NativeCall<FText*, FText*, FText>(nullptr, "UKismetSystemLibrary.MakeLiteralText", result, Value); }
	//static void QuitGame(UObject* WorldContextObject, APlayerController* SpecificPlayer, TEnumAsByte<enum EQuitPreference::Type> QuitPreference) { NativeCall<void, UObject*, APlayerController*, TEnumAsByte<enum EQuitPreference::Type>>(nullptr, "UKismetSystemLibrary.QuitGame", WorldContextObject, SpecificPlayer, QuitPreference); }
	static void K2_SetTimer(UObject* Object, FString FunctionName, float Time, bool bLooping) { NativeCall<void, UObject*, FString, float, bool>(nullptr, "UKismetSystemLibrary.K2_SetTimer(UObject*,FString,float,bool,float,float)", Object, FunctionName, Time, bLooping); }
	static void K2_SetTimerForNextTick(UObject* Object, FString FunctionName, bool bLooping) { NativeCall<void, UObject*, FString, bool>(nullptr, "UKismetSystemLibrary.K2_SetTimerForNextTick(UObject*,FString,bool)", Object, FunctionName, bLooping); }
	static void K2_SetTimerDelegate(FBlueprintTimerDynamicDelegate Delegate, float Time, bool bLooping) { NativeCall<void, FBlueprintTimerDynamicDelegate, float, bool>(nullptr, "UKismetSystemLibrary.K2_SetTimerDelegate(FTimerDynamicDelegate,float,bool,float,float)", Delegate, Time, bLooping); }
	static void K2_SetTimerForNextTickDelegate(FBlueprintTimerDynamicDelegate Delegate, bool bLooping) { NativeCall<void, FBlueprintTimerDynamicDelegate, bool>(nullptr, "UKismetSystemLibrary.K2_SetTimerForNextTickDelegate(FBlueprintTimerDynamicDelegate,bool)", Delegate, bLooping); }
	static void K2_ClearTimer(UObject* Object, FString FunctionName) { NativeCall<void, UObject*, FString>(nullptr, "UKismetSystemLibrary.K2_ClearTimer(UObject*,FString)", Object, FunctionName); }
	static void K2_PauseTimer(UObject* Object, FString FunctionName) { NativeCall<void, UObject*, FString>(nullptr, "UKismetSystemLibrary.K2_PauseTimer(UObject*,FString)", Object, FunctionName); }
	static void K2_UnPauseTimer(UObject* Object, FString FunctionName) { NativeCall<void, UObject*, FString>(nullptr, "UKismetSystemLibrary.K2_UnPauseTimer(UObject*,FString)", Object, FunctionName); }
	static bool K2_IsTimerActive(UObject* Object, FString FunctionName) { return NativeCall<bool, UObject*, FString>(nullptr, "UKismetSystemLibrary.K2_IsTimerActive(UObject*,FString)", Object, FunctionName); }
	static bool K2_IsTimerPaused(UObject* Object, FString FunctionName) { return NativeCall<bool, UObject*, FString>(nullptr, "UKismetSystemLibrary.K2_IsTimerPaused(UObject*,FString)", Object, FunctionName); }
	static bool K2_TimerExists(UObject* Object, FString FunctionName) { return NativeCall<bool, UObject*, FString>(nullptr, "UKismetSystemLibrary.K2_TimerExists(UObject*,FString)", Object, FunctionName); }
	static float K2_GetTimerElapsedTime(UObject* Object, FString FunctionName) { return NativeCall<float, UObject*, FString>(nullptr, "UKismetSystemLibrary.K2_GetTimerElapsedTime(UObject*,FString)", Object, FunctionName); }
	static float K2_GetTimerRemainingTime(UObject* Object, FString FunctionName) { return NativeCall<float, UObject*, FString>(nullptr, "UKismetSystemLibrary.K2_GetTimerRemainingTime(UObject*,FString)", Object, FunctionName); }
	//static void SetClassPropertyByName(UObject* Object, FName PropertyName, TSubclassOf<UObject> Value) { NativeCall<void, UObject*, FName, TSubclassOf<UObject>>(nullptr, "UKismetSystemLibrary.SetClassPropertyByName", Object, PropertyName, Value); }
	//static void SetVectorPropertyByName(UObject* Object, FName PropertyName, FVector* Value) { NativeCall<void, UObject*, FName, FVector*>(nullptr, "UKismetSystemLibrary.SetVectorPropertyByName", Object, PropertyName, Value); }
	//static void SetRotatorPropertyByName(UObject* Object, FName PropertyName, FRotator* Value) { NativeCall<void, UObject*, FName, FRotator*>(nullptr, "UKismetSystemLibrary.SetRotatorPropertyByName", Object, PropertyName, Value); }
	//static void SetLinearColorPropertyByName(UObject* Object, FName PropertyName, FLinearColor* Value) { NativeCall<void, UObject*, FName, FLinearColor*>(nullptr, "UKismetSystemLibrary.SetLinearColorPropertyByName", Object, PropertyName, Value); }
	//static void SetTransformPropertyByName(UObject* Object, FName PropertyName, FTransform* Value) { NativeCall<void, UObject*, FName, FTransform*>(nullptr, "UKismetSystemLibrary.SetTransformPropertyByName", Object, PropertyName, Value); }
	static void GetActorListFromComponentList(TArray<UPrimitiveComponent*>* ComponentList, UClass* ActorClassFilter, TArray<AActor*>* OutActorList) { NativeCall<void, TArray<UPrimitiveComponent*>*, UClass*, TArray<AActor*>*>(nullptr, "UKismetSystemLibrary.GetActorListFromComponentList(TArray<UPrimitiveComponent*,TSizedDefaultAllocator<32>>&,UClass*,TArray<AActor*,TSizedDefaultAllocator<32>>&)", ComponentList, ActorClassFilter, OutActorList); }
	static bool SphereOverlapActors(UObject* WorldContextObject, FVector SpherePos, float SphereRadius, TArray<TEnumAsByte<enum EObjectTypeQuery>>* ObjectTypes, UClass* ActorClassFilter, TArray<AActor*>* ActorsToIgnore, TArray<AActor*>* OutActors) { return NativeCall<bool, UObject*, FVector, float, TArray<TEnumAsByte<enum EObjectTypeQuery>>*, UClass*, TArray<AActor*>*, TArray<AActor*>*>(nullptr, "UKismetSystemLibrary.SphereOverlapActors(UObject*,UE::Math::TVector<double>,float,TArray<TEnumAsByte<EObjectTypeQuery>,TSizedDefaultAllocator<32>>&,UClass*,TArray<AActor*,TSizedDefaultAllocator<32>>&,TArray<AActor*,TSizedDefaultAllocator<32>>&)", WorldContextObject, SpherePos, SphereRadius, ObjectTypes, ActorClassFilter, ActorsToIgnore, OutActors); }
	static bool SphereOverlapActorsSimple(UObject* WorldContextObject, FVector SpherePos, float SphereRadius, TEnumAsByte<enum EObjectTypeQuery> ObjectType, UClass* ActorClassFilter, TArray<AActor*>* ActorsToIgnore, TArray<AActor*>* OutActors) { return NativeCall<bool, UObject*, FVector, float, TEnumAsByte<enum EObjectTypeQuery>, UClass*, TArray<AActor*>*, TArray<AActor*>*>(nullptr, "UKismetSystemLibrary.SphereOverlapActorsSimple(UObject*,UE::Math::TVector<double>,float,TEnumAsByte<EObjectTypeQuery>,UClass*,TArray<AActor*,TSizedDefaultAllocator<32>>&,TArray<AActor*,TSizedDefaultAllocator<32>>&)", WorldContextObject, SpherePos, SphereRadius, ObjectType, ActorClassFilter, ActorsToIgnore, OutActors); }
	static bool SphereOverlapComponents_NEW(UObject* WorldContextObject, FVector SpherePos, float SphereRadius, TArray<TEnumAsByte<enum EObjectTypeQuery>>* ObjectTypes, UClass* ComponentClassFilter, TArray<AActor*>* ActorsToIgnore, TArray<UPrimitiveComponent*>* OutComponents) { return NativeCall<bool, UObject*, FVector, float, TArray<TEnumAsByte<enum EObjectTypeQuery>>*, UClass*, TArray<AActor*>*, TArray<UPrimitiveComponent*>*>(nullptr, "UKismetSystemLibrary.SphereOverlapComponents_NEW(UObject*,UE::Math::TVector<double>,float,TArray<TEnumAsByte<EObjectTypeQuery>,TSizedDefaultAllocator<32>>&,UClass*,TArray<AActor*,TSizedDefaultAllocator<32>>&,TArray<UPrimitiveComponent*,TSizedDefaultAllocator<32>>&)", WorldContextObject, SpherePos, SphereRadius, ObjectTypes, ComponentClassFilter, ActorsToIgnore, OutComponents); }
	//static bool BoxOverlapActors_NEW(UObject* WorldContextObject, FVector BoxPos, FVector BoxExtent, TArray<TEnumAsByte<enum EObjectTypeQuery>>* ObjectTypes, UClass* ActorClassFilter, TArray<AActor*>* ActorsToIgnore, TArray<AActor*>* OutActors) { return NativeCall<bool, UObject*, FVector, FVector, TArray<TEnumAsByte<enum EObjectTypeQuery>>*, UClass*, TArray<AActor*>*, TArray<AActor*>*>(nullptr, "UKismetSystemLibrary.BoxOverlapActors_NEW", WorldContextObject, BoxPos, BoxExtent, ObjectTypes, ActorClassFilter, ActorsToIgnore, OutActors); }
	static bool BoxOverlapComponents(UObject* WorldContextObject, FVector BoxPos, FVector BoxExtent, TArray<TEnumAsByte<enum EObjectTypeQuery>>* ObjectTypes, UClass* ComponentClassFilter, TArray<AActor*>* ActorsToIgnore, TArray<UPrimitiveComponent*>* OutComponents) { return NativeCall<bool, UObject*, FVector, FVector, TArray<TEnumAsByte<enum EObjectTypeQuery>>*, UClass*, TArray<AActor*>*, TArray<UPrimitiveComponent*>*>(nullptr, "UKismetSystemLibrary.BoxOverlapComponents(UObject*,UE::Math::TVector<double>,UE::Math::TVector<double>,TArray<TEnumAsByte<EObjectTypeQuery>,TSizedDefaultAllocator<32>>&,UClass*,TArray<AActor*,TSizedDefaultAllocator<32>>&,TArray<UPrimitiveComponent*,TSizedDefaultAllocator<32>>&)", WorldContextObject, BoxPos, BoxExtent, ObjectTypes, ComponentClassFilter, ActorsToIgnore, OutComponents); }
	static bool CapsuleOverlapActors(UObject* WorldContextObject, FVector CapsulePos, float Radius, float HalfHeight, TArray<TEnumAsByte<enum EObjectTypeQuery>>* ObjectTypes, UClass* ActorClassFilter, TArray<AActor*>* ActorsToIgnore, TArray<AActor*>* OutActors) { return NativeCall<bool, UObject*, FVector, float, float, TArray<TEnumAsByte<enum EObjectTypeQuery>>*, UClass*, TArray<AActor*>*, TArray<AActor*>*>(nullptr, "UKismetSystemLibrary.CapsuleOverlapActors(UObject*,UE::Math::TVector<double>,float,float,TArray<TEnumAsByte<EObjectTypeQuery>,TSizedDefaultAllocator<32>>&,UClass*,TArray<AActor*,TSizedDefaultAllocator<32>>&,TArray<AActor*,TSizedDefaultAllocator<32>>&)", WorldContextObject, CapsulePos, Radius, HalfHeight, ObjectTypes, ActorClassFilter, ActorsToIgnore, OutActors); }
	static bool CapsuleOverlapComponents(UObject* WorldContextObject, FVector CapsulePos, float Radius, float HalfHeight, TArray<TEnumAsByte<enum EObjectTypeQuery>>* ObjectTypes, UClass* ComponentClassFilter, TArray<AActor*>* ActorsToIgnore, TArray<UPrimitiveComponent*>* OutComponents) { return NativeCall<bool, UObject*, FVector, float, float, TArray<TEnumAsByte<enum EObjectTypeQuery>>*, UClass*, TArray<AActor*>*, TArray<UPrimitiveComponent*>*>(nullptr, "UKismetSystemLibrary.CapsuleOverlapComponents(UObject*,UE::Math::TVector<double>,float,float,TArray<TEnumAsByte<EObjectTypeQuery>,TSizedDefaultAllocator<32>>&,UClass*,TArray<AActor*,TSizedDefaultAllocator<32>>&,TArray<UPrimitiveComponent*,TSizedDefaultAllocator<32>>&)", WorldContextObject, CapsulePos, Radius, HalfHeight, ObjectTypes, ComponentClassFilter, ActorsToIgnore, OutComponents); }
	//static bool ComponentOverlapActors_NEW(UPrimitiveComponent* Component, FTransform* ComponentTransform, TArray<TEnumAsByte<enum EObjectTypeQuery>>* ObjectTypes, UClass* ActorClassFilter, TArray<AActor*>* ActorsToIgnore, TArray<AActor*>* OutActors) { return NativeCall<bool, UPrimitiveComponent*, FTransform*, TArray<TEnumAsByte<enum EObjectTypeQuery>>*, UClass*, TArray<AActor*>*, TArray<AActor*>*>(nullptr, "UKismetSystemLibrary.ComponentOverlapActors_NEW", Component, ComponentTransform, ObjectTypes, ActorClassFilter, ActorsToIgnore, OutActors); }
	static bool ComponentOverlapComponents(UPrimitiveComponent* Component, FTransform* ComponentTransform, TArray<TEnumAsByte<enum EObjectTypeQuery>>* ObjectTypes, UClass* ComponentClassFilter, TArray<AActor*>* ActorsToIgnore, TArray<UPrimitiveComponent*>* OutComponents) { return NativeCall<bool, UPrimitiveComponent*, FTransform*, TArray<TEnumAsByte<enum EObjectTypeQuery>>*, UClass*, TArray<AActor*>*, TArray<UPrimitiveComponent*>*>(nullptr, "UKismetSystemLibrary.ComponentOverlapComponents(UPrimitiveComponent*,UE::Math::TTransform<double>&,TArray<TEnumAsByte<EObjectTypeQuery>,TSizedDefaultAllocator<32>>&,UClass*,TArray<AActor*,TSizedDefaultAllocator<32>>&,TArray<UPrimitiveComponent*,TSizedDefaultAllocator<32>>&)", Component, ComponentTransform, ObjectTypes, ComponentClassFilter, ActorsToIgnore, OutComponents); }
	static bool BoxTraceSingle(UObject* WorldContextObject, FVector Start, FVector End, FVector HalfSize, FRotator Orientation, ETraceTypeQuery TraceChannel, bool bTraceComplex, TArray<AActor*>* ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, FHitResult* OutHit, bool bIgnoreSelf) { return NativeCall<bool, UObject*, FVector, FVector, FVector, FRotator, ETraceTypeQuery, bool, TArray<AActor*>*, EDrawDebugTrace::Type, FHitResult*, bool>(nullptr, "UKismetSystemLibrary.BoxTraceSingle(UObject*,UE::Math::TVector<double>,UE::Math::TVector<double>,UE::Math::TVector<double>,UE::Math::TRotator<double>,ETraceTypeQuery,bool,TArray<AActor*,TSizedDefaultAllocator<32>>&,EDrawDebugTrace::Type,FHitResult&,bool,FLinearColor,FLinearColor,float)", WorldContextObject, Start, End, HalfSize, Orientation, TraceChannel, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHit, bIgnoreSelf); }
	static bool BoxTraceMulti(UObject* WorldContextObject, FVector Start, FVector End, FVector HalfSize, FRotator Orientation, ETraceTypeQuery TraceChannel, bool bTraceComplex, TArray<AActor*>* ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, TArray<FHitResult>* OutHits, bool bIgnoreSelf) { return NativeCall<bool, UObject*, FVector, FVector, FVector, FRotator, ETraceTypeQuery, bool, TArray<AActor*>*, EDrawDebugTrace::Type, TArray<FHitResult>*, bool>(nullptr, "UKismetSystemLibrary.BoxTraceMulti(UObject*,UE::Math::TVector<double>,UE::Math::TVector<double>,UE::Math::TVector<double>,UE::Math::TRotator<double>,ETraceTypeQuery,bool,TArray<AActor*,TSizedDefaultAllocator<32>>&,EDrawDebugTrace::Type,TArray<FHitResult,TSizedDefaultAllocator<32>>&,bool,FLinearColor,FLinearColor,float)", WorldContextObject, Start, End, HalfSize, Orientation, TraceChannel, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHits, bIgnoreSelf); }
	static bool LineTraceSingleForObjects(UObject* WorldContextObject, FVector Start, FVector End, TArray<TEnumAsByte<enum EObjectTypeQuery>>* ObjectTypes, bool bTraceComplex, TArray<AActor*>* ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, FHitResult* OutHit, bool bIgnoreSelf) { return NativeCall<bool, UObject*, FVector, FVector, TArray<TEnumAsByte<enum EObjectTypeQuery>>*, bool, TArray<AActor*>*, EDrawDebugTrace::Type, FHitResult*, bool>(nullptr, "UKismetSystemLibrary.LineTraceSingleForObjects(UObject*,UE::Math::TVector<double>,UE::Math::TVector<double>,TArray<TEnumAsByte<EObjectTypeQuery>,TSizedDefaultAllocator<32>>&,bool,TArray<AActor*,TSizedDefaultAllocator<32>>&,EDrawDebugTrace::Type,FHitResult&,bool,FLinearColor,FLinearColor,float)", WorldContextObject, Start, End, ObjectTypes, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHit, bIgnoreSelf); }
	static bool LineTraceMultiForObjects(UObject* WorldContextObject, FVector Start, FVector End, TArray<TEnumAsByte<enum EObjectTypeQuery>>* ObjectTypes, bool bTraceComplex, TArray<AActor*>* ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, TArray<FHitResult>* OutHits, bool bIgnoreSelf) { return NativeCall<bool, UObject*, FVector, FVector, TArray<TEnumAsByte<enum EObjectTypeQuery>>*, bool, TArray<AActor*>*, EDrawDebugTrace::Type, TArray<FHitResult>*, bool>(nullptr, "UKismetSystemLibrary.LineTraceMultiForObjects(UObject*,UE::Math::TVector<double>,UE::Math::TVector<double>,TArray<TEnumAsByte<EObjectTypeQuery>,TSizedDefaultAllocator<32>>&,bool,TArray<AActor*,TSizedDefaultAllocator<32>>&,EDrawDebugTrace::Type,TArray<FHitResult,TSizedDefaultAllocator<32>>&,bool,FLinearColor,FLinearColor,float)", WorldContextObject, Start, End, ObjectTypes, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHits, bIgnoreSelf); }
	static bool SphereTraceSingleForObjects(UObject* WorldContextObject, FVector Start, FVector End, float Radius, TArray<TEnumAsByte<enum EObjectTypeQuery>>* ObjectTypes, bool bTraceComplex, TArray<AActor*>* ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, FHitResult* OutHit, bool bIgnoreSelf) { return NativeCall<bool, UObject*, FVector, FVector, float, TArray<TEnumAsByte<enum EObjectTypeQuery>>*, bool, TArray<AActor*>*, EDrawDebugTrace::Type, FHitResult*, bool>(nullptr, "UKismetSystemLibrary.SphereTraceSingleForObjects(UObject*,UE::Math::TVector<double>,UE::Math::TVector<double>,float,TArray<TEnumAsByte<EObjectTypeQuery>,TSizedDefaultAllocator<32>>&,bool,TArray<AActor*,TSizedDefaultAllocator<32>>&,EDrawDebugTrace::Type,FHitResult&,bool,FLinearColor,FLinearColor,float)", WorldContextObject, Start, End, Radius, ObjectTypes, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHit, bIgnoreSelf); }
	static bool SphereTraceMultiForObjects(UObject* WorldContextObject, FVector Start, FVector End, float Radius, TArray<TEnumAsByte<enum EObjectTypeQuery>>* ObjectTypes, bool bTraceComplex, TArray<AActor*>* ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, TArray<FHitResult>* OutHits, bool bIgnoreSelf) { return NativeCall<bool, UObject*, FVector, FVector, float, TArray<TEnumAsByte<enum EObjectTypeQuery>>*, bool, TArray<AActor*>*, EDrawDebugTrace::Type, TArray<FHitResult>*, bool>(nullptr, "UKismetSystemLibrary.SphereTraceMultiForObjects(UObject*,UE::Math::TVector<double>,UE::Math::TVector<double>,float,TArray<TEnumAsByte<EObjectTypeQuery>,TSizedDefaultAllocator<32>>&,bool,TArray<AActor*,TSizedDefaultAllocator<32>>&,EDrawDebugTrace::Type,TArray<FHitResult,TSizedDefaultAllocator<32>>&,bool,FLinearColor,FLinearColor,float)", WorldContextObject, Start, End, Radius, ObjectTypes, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHits, bIgnoreSelf); }
	static bool BoxTraceSingleForObjects(UObject* WorldContextObject, FVector Start, FVector End, FVector HalfSize, FRotator Orientation, TArray<TEnumAsByte<enum EObjectTypeQuery>>* ObjectTypes, bool bTraceComplex, TArray<AActor*>* ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, FHitResult* OutHit, bool bIgnoreSelf) { return NativeCall<bool, UObject*, FVector, FVector, FVector, FRotator, TArray<TEnumAsByte<enum EObjectTypeQuery>>*, bool, TArray<AActor*>*, EDrawDebugTrace::Type, FHitResult*, bool>(nullptr, "UKismetSystemLibrary.BoxTraceSingleForObjects(UObject*,UE::Math::TVector<double>,UE::Math::TVector<double>,UE::Math::TVector<double>,UE::Math::TRotator<double>,TArray<TEnumAsByte<EObjectTypeQuery>,TSizedDefaultAllocator<32>>&,bool,TArray<AActor*,TSizedDefaultAllocator<32>>&,EDrawDebugTrace::Type,FHitResult&,bool,FLinearColor,FLinearColor,float)", WorldContextObject, Start, End, HalfSize, Orientation, ObjectTypes, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHit, bIgnoreSelf); }
	static bool BoxTraceMultiForObjects(UObject* WorldContextObject, FVector Start, FVector End, FVector HalfSize, FRotator Orientation, TArray<TEnumAsByte<enum EObjectTypeQuery>>* ObjectTypes, bool bTraceComplex, TArray<AActor*>* ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, TArray<FHitResult>* OutHits, bool bIgnoreSelf) { return NativeCall<bool, UObject*, FVector, FVector, FVector, FRotator, TArray<TEnumAsByte<enum EObjectTypeQuery>>*, bool, TArray<AActor*>*, EDrawDebugTrace::Type, TArray<FHitResult>*, bool>(nullptr, "UKismetSystemLibrary.BoxTraceMultiForObjects(UObject*,UE::Math::TVector<double>,UE::Math::TVector<double>,UE::Math::TVector<double>,UE::Math::TRotator<double>,TArray<TEnumAsByte<EObjectTypeQuery>,TSizedDefaultAllocator<32>>&,bool,TArray<AActor*,TSizedDefaultAllocator<32>>&,EDrawDebugTrace::Type,TArray<FHitResult,TSizedDefaultAllocator<32>>&,bool,FLinearColor,FLinearColor,float)", WorldContextObject, Start, End, HalfSize, Orientation, ObjectTypes, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHits, bIgnoreSelf); }
	static bool CapsuleTraceSingleForObjects(UObject* WorldContextObject, FVector Start, FVector End, float Radius, float HalfHeight, TArray<TEnumAsByte<enum EObjectTypeQuery>>* ObjectTypes, bool bTraceComplex, TArray<AActor*>* ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, FHitResult* OutHit, bool bIgnoreSelf) { return NativeCall<bool, UObject*, FVector, FVector, float, float, TArray<TEnumAsByte<enum EObjectTypeQuery>>*, bool, TArray<AActor*>*, EDrawDebugTrace::Type, FHitResult*, bool>(nullptr, "UKismetSystemLibrary.CapsuleTraceSingleForObjects(UObject*,UE::Math::TVector<double>,UE::Math::TVector<double>,float,float,TArray<TEnumAsByte<EObjectTypeQuery>,TSizedDefaultAllocator<32>>&,bool,TArray<AActor*,TSizedDefaultAllocator<32>>&,EDrawDebugTrace::Type,FHitResult&,bool,FLinearColor,FLinearColor,float)", WorldContextObject, Start, End, Radius, HalfHeight, ObjectTypes, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHit, bIgnoreSelf); }
	static bool CapsuleTraceMultiForObjects(UObject* WorldContextObject, FVector Start, FVector End, float Radius, float HalfHeight, TArray<TEnumAsByte<enum EObjectTypeQuery>>* ObjectTypes, bool bTraceComplex, TArray<AActor*>* ActorsToIgnore, EDrawDebugTrace::Type DrawDebugType, TArray<FHitResult>* OutHits, bool bIgnoreSelf) { return NativeCall<bool, UObject*, FVector, FVector, float, float, TArray<TEnumAsByte<enum EObjectTypeQuery>>*, bool, TArray<AActor*>*, EDrawDebugTrace::Type, TArray<FHitResult>*, bool>(nullptr, "UKismetSystemLibrary.CapsuleTraceMultiForObjects(UObject*,UE::Math::TVector<double>,UE::Math::TVector<double>,float,float,TArray<TEnumAsByte<EObjectTypeQuery>,TSizedDefaultAllocator<32>>&,bool,TArray<AActor*,TSizedDefaultAllocator<32>>&,EDrawDebugTrace::Type,TArray<FHitResult,TSizedDefaultAllocator<32>>&,bool,FLinearColor,FLinearColor,float)", WorldContextObject, Start, End, Radius, HalfHeight, ObjectTypes, bTraceComplex, ActorsToIgnore, DrawDebugType, OutHits, bIgnoreSelf); }
	//static void DrawDebugFrustum(UObject* WorldContextObject, FTransform* FrustumTransform, FLinearColor FrustumColor, float Duration) { NativeCall<void, UObject*, FTransform*, FLinearColor, float>(nullptr, "UKismetSystemLibrary.DrawDebugFrustum", WorldContextObject, FrustumTransform, FrustumColor, Duration); }
	//static void DrawDebugFloatHistoryLocation(UObject* WorldContextObject, FDebugFloatHistory* FloatHistory, FVector DrawLocation, FVector2D DrawSize, FLinearColor DrawColor, float LifeTime) { NativeCall<void, UObject*, FDebugFloatHistory*, FVector, FVector2D, FLinearColor, float>(nullptr, "UKismetSystemLibrary.DrawDebugFloatHistoryLocation", WorldContextObject, FloatHistory, DrawLocation, DrawSize, DrawColor, LifeTime); }
	static FDebugFloatHistory* AddFloatHistorySample(FDebugFloatHistory* result, float Value, FDebugFloatHistory* FloatHistory) { return NativeCall<FDebugFloatHistory*, FDebugFloatHistory*, float, FDebugFloatHistory*>(nullptr, "UKismetSystemLibrary.AddFloatHistorySample(float,FDebugFloatHistory&)", result, Value, FloatHistory); }
	//static void GetActorBounds(AActor* Actor, FVector* Origin, FVector* BoxExtent) { NativeCall<void, AActor*, FVector*, FVector*>(nullptr, "UKismetSystemLibrary.GetActorBounds", Actor, Origin, BoxExtent); }
	//static void Delay(UObject* WorldContextObject, float Duration, FLatentActionInfo LatentInfo) { NativeCall<void, UObject*, float, FLatentActionInfo>(nullptr, "UKismetSystemLibrary.Delay", WorldContextObject, Duration, LatentInfo); }
	//static void RetriggerableDelay(UObject* WorldContextObject, float Duration, FLatentActionInfo LatentInfo) { NativeCall<void, UObject*, float, FLatentActionInfo>(nullptr, "UKismetSystemLibrary.RetriggerableDelay", WorldContextObject, Duration, LatentInfo); }
	//static void MoveComponentTo(USceneComponent* Component, FVector TargetRelativeLocation, FRotator TargetRelativeRotation, bool bEaseOut, bool bEaseIn, float OverTime, TEnumAsByte<enum EMoveComponentAction::Type> MoveAction, FLatentActionInfo LatentInfo, bool bSweep) { NativeCall<void, USceneComponent*, FVector, FRotator, bool, bool, float, TEnumAsByte<enum EMoveComponentAction::Type>, FLatentActionInfo, bool>(nullptr, "UKismetSystemLibrary.MoveComponentTo", Component, TargetRelativeLocation, TargetRelativeRotation, bEaseOut, bEaseIn, OverTime, MoveAction, LatentInfo, bSweep); }
	//static int GetRenderingDetailMode() { return NativeCall<int>(nullptr, "UKismetSystemLibrary.GetRenderingDetailMode"); }
	//static int GetRenderingMaterialQualityLevel() { return NativeCall<int>(nullptr, "UKismetSystemLibrary.GetRenderingMaterialQualityLevel"); }
	//static void ShowPlatformSpecificAchievementsScreen(APlayerController* SpecificPlayer) { NativeCall<void, APlayerController*>(nullptr, "UKismetSystemLibrary.ShowPlatformSpecificAchievementsScreen", SpecificPlayer); }
	static void StaticRegisterNativesUKismetSystemLibrary() { NativeCall<void>(nullptr, "UKismetSystemLibrary.StaticRegisterNativesUKismetSystemLibrary()"); }
};

struct FStringHash
{
	std::size_t operator()(const FString& str) const
	{
		const std::string stdString(TCHAR_TO_UTF8(*str));
		return std::hash<std::string>{}(stdString);
	}
};

struct FStringEqual
{
	bool operator()(const FString& lhs, const FString& rhs) const
	{
		return lhs.Equals(rhs);
	}
};