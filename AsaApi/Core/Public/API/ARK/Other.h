#pragma once
enum class ESocketType
{
	SOCKTYPE_Unknown = 0x0,
	SOCKTYPE_Datagram = 0x1,
	SOCKTYPE_Streaming = 0x2,
};
struct RCONPacket
{
	int Length;
	int Id;
	int Type;
	FString Body;
};
struct FSocket
{
	ESocketType& SocketTypeField() { return *GetNativePointerField<ESocketType*>(this, "FSocket.SocketType"); }
	FString& SocketDescriptionField() { return *GetNativePointerField<FString*>(this, "FSocket.SocketDescription"); }
};
struct RCONClientConnection
{
	FSocket* SocketField() { return *GetNativePointerField<FSocket**>(this, "RCONClientConnection.Socket"); }
	UShooterCheatManager* CheatManagerField() { return *GetNativePointerField<UShooterCheatManager**>(this, "RCONClientConnection.CheatManager"); }
	bool& IsAuthenticatedField() { return *GetNativePointerField<bool*>(this, "RCONClientConnection.IsAuthenticated"); }
	bool& IsClosedField() { return *GetNativePointerField<bool*>(this, "RCONClientConnection.IsClosed"); }
	TArray<signed char>& DataBufferField() { return *GetNativePointerField<TArray<signed char>*>(this, "RCONClientConnection.DataBuffer"); }
	unsigned int& CurrentPacketSizeField() { return *GetNativePointerField<unsigned int*>(this, "RCONClientConnection.CurrentPacketSize"); }
	long double& LastReceiveTimeField() { return *GetNativePointerField<long double*>(this, "RCONClientConnection.LastReceiveTime"); }
	long double& LastSendKeepAliveTimeField() { return *GetNativePointerField<long double*>(this, "RCONClientConnection.LastSendKeepAliveTime"); }
	FString& ServerPasswordField() { return *GetNativePointerField<FString*>(this, "RCONClientConnection.ServerPassword"); }

	// Functions

	void Tick(long double WorldTime, UWorld* InWorld) { NativeCall<void, long double, UWorld*>(this, "RCONClientConnection.Tick(double,UWorld*)", WorldTime, InWorld); }
	void ProcessRCONPacket(RCONPacket* Packet, UWorld* InWorld) { NativeCall<void, RCONPacket*, UWorld*>(this, "RCONClientConnection.ProcessRCONPacket(RCONPacket&,UWorld*)", Packet, InWorld); }
	void SendMessageW(int Id, int Type, FString* OutGoingMessage) { NativeCall<void, int, int, FString*>(this, "RCONClientConnection.SendMessage(int,int,FString&)", Id, Type, OutGoingMessage); }
	void Close() { NativeCall<void>(this, "RCONClientConnection.Close()"); }
};
struct UVictoryCoreHighest : UObject
{
	// Fields


	  // Bitfields


	  // Functions

	static UClass* StaticClass() { return NativeCall<UClass*>(nullptr, "UVictoryCoreHighest.StaticClass()"); }
};

struct UVictoryCore : UVictoryCoreHighest
{
	// Fields


	  // Bitfields


	  // Functions

	static void StaticRegisterNativesUVictoryCore() { NativeCall<void>(nullptr, "UVictoryCore.StaticRegisterNativesUVictoryCore()"); }
	static UClass* GetPrivateStaticClass() { return NativeCall<UClass*>(nullptr, "UVictoryCore.GetPrivateStaticClass()"); }
	static void DestroyWidget(UWidget* WidgetToDestroy) { NativeCall<void, UWidget*>(nullptr, "UVictoryCore.DestroyWidget(UWidget*)", WidgetToDestroy); }
	static int RandInt(int MaxVal) { return NativeCall<int, int>(nullptr, "UVictoryCore.RandInt(int)", MaxVal); }
	static int GetWeightedRandomIndex(const TArray<float, TSizedDefaultAllocator<32> >* pArray, float ForceRand) { return NativeCall<int, const TArray<float, TSizedDefaultAllocator<32> >*, float>(nullptr, "UVictoryCore.GetWeightedRandomIndex(TArray<float,TSizedDefaultAllocator<32>>*,float)", pArray, ForceRand); }
	static _BOOL8 OverlappingActors() { return NativeCall<_BOOL8>(nullptr, "UVictoryCore.OverlappingActors()"); }
	static int IsChildOfClassesSoftRefT<class APrimalBuff>(TSubclassOf<UObject> childClass, const TArray<TSoftClassPtr<APrimalBuff>, TSizedDefaultAllocator<32> >* ParentClassesArray) { return NativeCall<int, TSubclassOf<UObject>, const TArray<TSoftClassPtr<APrimalBuff>, TSizedDefaultAllocator<32> >*>(nullptr, "UVictoryCore.IsChildOfClassesSoftRefT<class APrimalBuff>(TSubclassOf<UObject>,TArray<TSoftClassPtr<APrimalBuff>,TSizedDefaultAllocator<32>>*)", childClass, ParentClassesArray); }
	static int IsChildOfClassesSoftRefT<class APrimalDinoCharacter>(TSubclassOf<UObject> childClass, const TArray<TSoftClassPtr<APrimalDinoCharacter>, TSizedDefaultAllocator<32> >* ParentClassesArray) { return NativeCall<int, TSubclassOf<UObject>, const TArray<TSoftClassPtr<APrimalDinoCharacter>, TSizedDefaultAllocator<32> >*>(nullptr, "UVictoryCore.IsChildOfClassesSoftRefT<class APrimalDinoCharacter>(TSubclassOf<UObject>,TArray<TSoftClassPtr<APrimalDinoCharacter>,TSizedDefaultAllocator<32>>*)", childClass, ParentClassesArray); }
	UShooterGameUserSettings* GetShooterGameUserSettings() { return NativeCall<UShooterGameUserSettings*>(this, "UVictoryCore.GetShooterGameUserSettings()"); }
	static UObjectBase* TracePhysMaterial() { return NativeCall<UObjectBase*>(nullptr, "UVictoryCore.TracePhysMaterial()"); }
	static UObject* GetClassDefaultObject(UClass* FromClass) { return NativeCall<UObject*, UClass*>(nullptr, "UVictoryCore.GetClassDefaultObject(UClass*)", FromClass); }
	static float ClampRotAxis(float BaseAxis, float DesiredAxis, float MaxDiff) { return NativeCall<float, float, float, float>(nullptr, "UVictoryCore.ClampRotAxis(float,float,float)", BaseAxis, DesiredAxis, MaxDiff); }
	static int BPGetWeightedRandomIndex(const TArray<float, TSizedDefaultAllocator<32> >* pArray, float ForceRand) { return NativeCall<int, const TArray<float, TSizedDefaultAllocator<32> >*, float>(nullptr, "UVictoryCore.BPGetWeightedRandomIndex(TArray<float,TSizedDefaultAllocator<32>>*,float)", pArray, ForceRand); }
	static bool ComponentBoundsEncompassesPoint(UPrimitiveComponent* Comp, const UE::Math::TVector<double>* Point, float BoundsMultiplier) { return NativeCall<bool, UPrimitiveComponent*, const UE::Math::TVector<double>*, float>(nullptr, "UVictoryCore.ComponentBoundsEncompassesPoint(UPrimitiveComponent*,UE::Math::TVector<double>*,float)", Comp, Point, BoundsMultiplier); }
	static bool SphereOverlapFast(UObject* WorldContextObject, const UE::Math::TVector<double>* Loc, const float Radius) { return NativeCall<bool, UObject*, const UE::Math::TVector<double>*, const float>(nullptr, "UVictoryCore.SphereOverlapFast(UObject*,UE::Math::TVector<double>*,float)", WorldContextObject, Loc, Radius); }
	static bool CapsuleOverlapFast(UObject* WorldContextObject, AActor** OutFirstOverlappedActor, const UE::Math::TVector<double>* Origin, const UE::Math::TRotator<double>* CapsuleRotation, float Radius, float HalfHeight, TEnumAsByte<enum ECollisionChannel> CollisionChannel, bool bTraceComplex, bool bIgnoreSelf, AActor* IgnoreActor, bool bDebugDraw, float DebugDrawDuration, bool bBlockingOnly) { return NativeCall<bool, UObject*, AActor**, const UE::Math::TVector<double>*, const UE::Math::TRotator<double>*, float, float, TEnumAsByte<enum ECollisionChannel>, bool, bool, AActor*, bool, float, bool>(nullptr, "UVictoryCore.CapsuleOverlapFast(UObject*,AActor**,UE::Math::TVector<double>*,UE::Math::TRotator<double>*,float,float,TEnumAsByte<enumECollisionChannel>,bool,bool,AActor*,bool,float,bool)", WorldContextObject, OutFirstOverlappedActor, Origin, CapsuleRotation, Radius, HalfHeight, CollisionChannel, bTraceComplex, bIgnoreSelf, IgnoreActor, bDebugDraw, DebugDrawDuration, bBlockingOnly); }
	static bool CapsuleSweepFast(UObject* WorldContextObject, FHitResult* OutHit, const UE::Math::TVector<double>* Start, const UE::Math::TVector<double>* End, const UE::Math::TRotator<double>* CapsuleRot, float Radius, float HalfHeight, TEnumAsByte<enum ECollisionChannel> CollisionChannel, bool bTraceComplex, bool bIgnoreSelf, const TArray<AActor*, TSizedDefaultAllocator<32> >* IgnoreActors, bool bDebugDraw, float DebugDrawDuration) { return NativeCall<bool, UObject*, FHitResult*, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*, const UE::Math::TRotator<double>*, float, float, TEnumAsByte<enum ECollisionChannel>, bool, bool, const TArray<AActor*, TSizedDefaultAllocator<32> >*, bool, float>(nullptr, "UVictoryCore.CapsuleSweepFast(UObject*,FHitResult*,UE::Math::TVector<double>*,UE::Math::TVector<double>*,UE::Math::TRotator<double>*,float,float,TEnumAsByte<enumECollisionChannel>,bool,bool,TArray<AActor*,TSizedDefaultAllocator<32>>*,bool,float)", WorldContextObject, OutHit, Start, End, CapsuleRot, Radius, HalfHeight, CollisionChannel, bTraceComplex, bIgnoreSelf, IgnoreActors, bDebugDraw, DebugDrawDuration); }
	static bool CapsuleSweepMulti(UObject* WorldContextObject, TArray<FHitResult, TSizedDefaultAllocator<32> >* OutHits, const UE::Math::TVector<double>* Start, const UE::Math::TVector<double>* End, const UE::Math::TRotator<double>* CapsuleRot, float Radius, float HalfHeight, const TArray<AActor*, TSizedDefaultAllocator<32> >* IgnoreActors, bool bIgnoreSelf, TEnumAsByte<enum ECollisionChannel> CollisionChannel, bool bTraceComplex, bool bDebugDraw, float DebugDrawDuration, bool bFindInitialOverlaps) { return NativeCall<bool, UObject*, TArray<FHitResult, TSizedDefaultAllocator<32> >*, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*, const UE::Math::TRotator<double>*, float, float, const TArray<AActor*, TSizedDefaultAllocator<32> >*, bool, TEnumAsByte<enum ECollisionChannel>, bool, bool, float, bool>(nullptr, "UVictoryCore.CapsuleSweepMulti(UObject*,TArray<FHitResult,TSizedDefaultAllocator<32>>*,UE::Math::TVector<double>*,UE::Math::TVector<double>*,UE::Math::TRotator<double>*,float,float,TArray<AActor*,TSizedDefaultAllocator<32>>*,bool,TEnumAsByte<enumECollisionChannel>,bool,bool,float,bool)", WorldContextObject, OutHits, Start, End, CapsuleRot, Radius, HalfHeight, IgnoreActors, bIgnoreSelf, CollisionChannel, bTraceComplex, bDebugDraw, DebugDrawDuration, bFindInitialOverlaps); }
	static void MultiTraceProjectSphere(UObject* WorldContextObject, TArray<FHitResult, TSizedDefaultAllocator<32> >* OutResults, const UE::Math::TVector<double>* Origin, ECollisionChannel TraceChannel, int HorizResolution, int VertResolution, float StartDistance, float EndDistance, float NorthConeSubtractAngle, float SouthConeSubtractAngle, int PctChanceToTrace, int MaxTraceCount, bool bDrawDebugLines, float DebugDrawDuration, bool bStopOnFirstHit) { NativeCall<void, UObject*, TArray<FHitResult, TSizedDefaultAllocator<32> >*, const UE::Math::TVector<double>*, ECollisionChannel, int, int, float, float, float, float, int, int, bool, float, bool>(nullptr, "UVictoryCore.MultiTraceProjectSphere(UObject*,TArray<FHitResult,TSizedDefaultAllocator<32>>*,UE::Math::TVector<double>*,ECollisionChannel,int,int,float,float,float,float,int,int,bool,float,bool)", WorldContextObject, OutResults, Origin, TraceChannel, HorizResolution, VertResolution, StartDistance, EndDistance, NorthConeSubtractAngle, SouthConeSubtractAngle, PctChanceToTrace, MaxTraceCount, bDrawDebugLines, DebugDrawDuration, bStopOnFirstHit); }
	static float GetProjectileArcPeakTime(UObject* WorldContextObject, const FProjectileArc* Arc) { return NativeCall<float, UObject*, const FProjectileArc*>(nullptr, "UVictoryCore.GetProjectileArcPeakTime(UObject*,FProjectileArc*)", WorldContextObject, Arc); }
	static void DrawDebugCapsule(UObject* WorldContextObject, const UE::Math::TVector<double>* CapsuleTop, const UE::Math::TVector<double>* CapsuleBottom, float Radius, const FColor* Color, bool bPersistentLines, float LifeTime, unsigned __int8 DepthPriority) { NativeCall<void, UObject*, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*, float, const FColor*, bool, float, unsigned __int8>(nullptr, "UVictoryCore.DrawDebugCapsule(UObject*,UE::Math::TVector<double>*,UE::Math::TVector<double>*,float,FColor*,bool,float,unsigned__int8)", WorldContextObject, CapsuleTop, CapsuleBottom, Radius, Color, bPersistentLines, LifeTime, DepthPriority); }
	static bool TraceProjectileArc(UObject* WorldContextObject, const FProjectileArc* Arc, FHitResult* OutHitResult, UE::Math::TVector<double>* OutEndLocation, float* OutEndArcTime, UE::Math::TVector<double>* OutArcPeakLocation, float MaxArcLength, const TArray<AActor*, TSizedDefaultAllocator<32> >* ActorsToIgnore, float ArcTimeStep, ECollisionChannel CollisionChannel, bool bTraceObjectTypeOnly, bool bDrawDebug, float DebugDrawDuration) { return NativeCall<bool, UObject*, const FProjectileArc*, FHitResult*, UE::Math::TVector<double>*, float*, UE::Math::TVector<double>*, float, const TArray<AActor*, TSizedDefaultAllocator<32> >*, float, ECollisionChannel, bool, bool, float>(nullptr, "UVictoryCore.TraceProjectileArc(UObject*,FProjectileArc*,FHitResult*,UE::Math::TVector<double>*,float*,UE::Math::TVector<double>*,float,TArray<AActor*,TSizedDefaultAllocator<32>>*,float,ECollisionChannel,bool,bool,float)", WorldContextObject, Arc, OutHitResult, OutEndLocation, OutEndArcTime, OutArcPeakLocation, MaxArcLength, ActorsToIgnore, ArcTimeStep, CollisionChannel, bTraceObjectTypeOnly, bDrawDebug, DebugDrawDuration); }
	static bool CapsuleSweepProjectileArc(UObject* WorldContextObject, const FProjectileArc* Arc, const UE::Math::TRotator<double>* CapsuleRotation, float CapsuleRadius, float CapsuleHalfHeight, bool bRotateCapsuleAlongPath, bool bTraceComplex, FHitResult* OutHitResult, UE::Math::TVector<double>* OutEndLocation, float* OutEndArcTime, float MaxArcLength, const TArray<AActor*, TSizedDefaultAllocator<32> >* ActorsToIgnore, bool bIgnoreSelf, float ArcTimeStep, TEnumAsByte<enum ECollisionChannel> CollisionChannel, bool bDrawDebug, float DebugDrawDuration) { return NativeCall<bool, UObject*, const FProjectileArc*, const UE::Math::TRotator<double>*, float, float, bool, bool, FHitResult*, UE::Math::TVector<double>*, float*, float, const TArray<AActor*, TSizedDefaultAllocator<32> >*, bool, float, TEnumAsByte<enum ECollisionChannel>, bool, float>(nullptr, "UVictoryCore.CapsuleSweepProjectileArc(UObject*,FProjectileArc*,UE::Math::TRotator<double>*,float,float,bool,bool,FHitResult*,UE::Math::TVector<double>*,float*,float,TArray<AActor*,TSizedDefaultAllocator<32>>*,bool,float,TEnumAsByte<enumECollisionChannel>,bool,float)", WorldContextObject, Arc, CapsuleRotation, CapsuleRadius, CapsuleHalfHeight, bRotateCapsuleAlongPath, bTraceComplex, OutHitResult, OutEndLocation, OutEndArcTime, MaxArcLength, ActorsToIgnore, bIgnoreSelf, ArcTimeStep, CollisionChannel, bDrawDebug, DebugDrawDuration); }
	static void MultiLinePenetrationTraceByChannel(UObject* WorldContextObject, TArray<FPenetrationTraceHit, TSizedDefaultAllocator<32> >* OutResults, const UE::Math::TVector<double>* Start, const UE::Math::TVector<double>* End, ECollisionChannel TraceChannel, const TArray<AActor*, TSizedDefaultAllocator<32> >* ActorsToIgnore, bool bTraceComplex, bool bIgnoreSelf, bool bDrawDebugLines, float DebugDrawDuration) { NativeCall<void, UObject*, TArray<FPenetrationTraceHit, TSizedDefaultAllocator<32> >*, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*, ECollisionChannel, const TArray<AActor*, TSizedDefaultAllocator<32> >*, bool, bool, bool, float>(nullptr, "UVictoryCore.MultiLinePenetrationTraceByChannel(UObject*,TArray<FPenetrationTraceHit,TSizedDefaultAllocator<32>>*,UE::Math::TVector<double>*,UE::Math::TVector<double>*,ECollisionChannel,TArray<AActor*,TSizedDefaultAllocator<32>>*,bool,bool,bool,float)", WorldContextObject, OutResults, Start, End, TraceChannel, ActorsToIgnore, bTraceComplex, bIgnoreSelf, bDrawDebugLines, DebugDrawDuration); }
	static bool FindValidLocationNextToTarget(UObject* WorldContextObject, UE::Math::TVector<double>* OutLocation, APrimalCharacter* SourceCharacter, APrimalCharacter* TargetCharacter, float DistanceMargin, int MaxTraceCount, AActor* ActorToIgnore, bool bTraceComplex, bool bDrawDebug, float DebugDrawDuration, bool AllowCloseDistance, bool AllowLocationInAir) { return NativeCall<bool, UObject*, UE::Math::TVector<double>*, APrimalCharacter*, APrimalCharacter*, float, int, AActor*, bool, bool, float, bool, bool>(nullptr, "UVictoryCore.FindValidLocationNextToTarget(UObject*,UE::Math::TVector<double>*,APrimalCharacter*,APrimalCharacter*,float,int,AActor*,bool,bool,float,bool,bool)", WorldContextObject, OutLocation, SourceCharacter, TargetCharacter, DistanceMargin, MaxTraceCount, ActorToIgnore, bTraceComplex, bDrawDebug, DebugDrawDuration, AllowCloseDistance, AllowLocationInAir); }
	static bool FindValidLocationInFrontOfTarget(UE::Math::TVector<double>* OutLocation, APrimalCharacter* SourceCharacter, APrimalCharacter* TargetCharacter, float DistanceMargin, TEnumAsByte<enum ECollisionChannel> CollisionChannel, bool bFailIfLocationNotOnGround, AActor* ActorToIgnore, bool bTraceComplex, float DebugDrawDuration) { return NativeCall<bool, UE::Math::TVector<double>*, APrimalCharacter*, APrimalCharacter*, float, TEnumAsByte<enum ECollisionChannel>, bool, AActor*, bool, float>(nullptr, "UVictoryCore.FindValidLocationInFrontOfTarget(UE::Math::TVector<double>*,APrimalCharacter*,APrimalCharacter*,float,TEnumAsByte<enumECollisionChannel>,bool,AActor*,bool,float)", OutLocation, SourceCharacter, TargetCharacter, DistanceMargin, CollisionChannel, bFailIfLocationNotOnGround, ActorToIgnore, bTraceComplex, DebugDrawDuration); }
	static void GridTraceAroundPoint() { NativeCall<void>(nullptr, "UVictoryCore.GridTraceAroundPoint()"); }
	static float SimpleCurveEval(float Value, TEnumAsByte<enum ESimpleCurve::Type> CurveType) { return NativeCall<float, float, TEnumAsByte<enum ESimpleCurve::Type>>(nullptr, "UVictoryCore.SimpleCurveEval(float,TEnumAsByte<enumESimpleCurve::Type>)", Value, CurveType); }
	static float SimpleCurveInterpClamped(float A, float B, float Alpha, TEnumAsByte<enum ESimpleCurve::Type> CurveType) { return NativeCall<float, float, float, float, TEnumAsByte<enum ESimpleCurve::Type>>(nullptr, "UVictoryCore.SimpleCurveInterpClamped(float,float,float,TEnumAsByte<enumESimpleCurve::Type>)", A, B, Alpha, CurveType); }
	static float MapRangeToCurveClamped(float Value, float InRangeA, float InRangeB, float OutRangeA, float OutRangeB, TEnumAsByte<enum ESimpleCurve::Type> CurveType) { return NativeCall<float, float, float, float, float, float, TEnumAsByte<enum ESimpleCurve::Type>>(nullptr, "UVictoryCore.MapRangeToCurveClamped(float,float,float,float,float,TEnumAsByte<enumESimpleCurve::Type>)", Value, InRangeA, InRangeB, OutRangeA, OutRangeB, CurveType); }
	static float MapAngleRangeToCurveClamped(float AngleDegrees, float InRangeA, float InRangeB, float OutRangeA, float OutRangeB, TEnumAsByte<enum ESimpleCurve::Type> CurveType) { return NativeCall<float, float, float, float, float, float, TEnumAsByte<enum ESimpleCurve::Type>>(nullptr, "UVictoryCore.MapAngleRangeToCurveClamped(float,float,float,float,float,TEnumAsByte<enumESimpleCurve::Type>)", AngleDegrees, InRangeA, InRangeB, OutRangeA, OutRangeB, CurveType); }
	static bool BPFastTrace() { return NativeCall<bool>(nullptr, "UVictoryCore.BPFastTrace()"); }
	static bool SplineLineTrace(USplineComponent* SplineComponent, const TArray<AActor*, TSizedDefaultAllocator<32> >* ActorsToIgnore, TArray<FHitResult, TSizedDefaultAllocator<32> >* OutHits, int NumTracesPerSegment, ECollisionChannel Channel, bool bStopOnBlockingHit, float DebugDrawDuration) { return NativeCall<bool, USplineComponent*, const TArray<AActor*, TSizedDefaultAllocator<32> >*, TArray<FHitResult, TSizedDefaultAllocator<32> >*, int, ECollisionChannel, bool, float>(nullptr, "UVictoryCore.SplineLineTrace(USplineComponent*,TArray<AActor*,TSizedDefaultAllocator<32>>*,TArray<FHitResult,TSizedDefaultAllocator<32>>*,int,ECollisionChannel,bool,float)", SplineComponent, ActorsToIgnore, OutHits, NumTracesPerSegment, Channel, bStopOnBlockingHit, DebugDrawDuration); }
	static bool VTraceIgnoreFoliage(UWorld* theWorld, const UE::Math::TVector<double>* Start, const UE::Math::TVector<double>* End, FHitResult* HitOut, const AActor* ActorToIgnore, ECollisionChannel Channel, int CollisionGroups, bool bReturnPhysMaterial, bool bTraceComplex, const UE::Math::TVector<double>* BoxExtent, FName TraceTag, const AActor* OtherActorToIgnore, TArray<AActor*, TSizedDefaultAllocator<32> >* OtherActorsToIgnore, const UE::Math::TQuat<double>* Rot, const AActor* AnotherActorToIgnore, bool bIgnoreFoliage) { return NativeCall<bool, UWorld*, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*, FHitResult*, const AActor*, ECollisionChannel, int, bool, bool, const UE::Math::TVector<double>*, FName, const AActor*, TArray<AActor*, TSizedDefaultAllocator<32> >*, const UE::Math::TQuat<double>*, const AActor*, bool>(nullptr, "UVictoryCore.VTraceIgnoreFoliage(UWorld*,UE::Math::TVector<double>*,UE::Math::TVector<double>*,FHitResult*,AActor*,ECollisionChannel,int,bool,bool,UE::Math::TVector<double>*,FName,AActor*,TArray<AActor*,TSizedDefaultAllocator<32>>*,UE::Math::TQuat<double>*,AActor*,bool)", theWorld, Start, End, HitOut, ActorToIgnore, Channel, CollisionGroups, bReturnPhysMaterial, bTraceComplex, BoxExtent, TraceTag, OtherActorToIgnore, OtherActorsToIgnore, Rot, AnotherActorToIgnore, bIgnoreFoliage); }
	static void SetSessionPrefix(const FString* InPrefix) { NativeCall<void, const FString*>(nullptr, "UVictoryCore.SetSessionPrefix(FString&)", InPrefix); }
	static FColor* GetTeamColor(FColor* result, const int TargetingTeam) { return NativeCall<FColor*, FColor*, const int>(nullptr, "UVictoryCore.GetTeamColor(FColor*,int)", result, TargetingTeam); }
	static FString* FormatAsTime(FString* result, int InTime, bool UseLeadingZero, bool bForceLeadingZeroHour, bool bShowSeconds) { return NativeCall<FString*, FString*, int, bool, bool, bool>(nullptr, "UVictoryCore.FormatAsTime(FString&,int,bool,bool,bool)", result, InTime, UseLeadingZero, bForceLeadingZeroHour, bShowSeconds); }
	static FString* FormatAsTimeLong(FString* result, int InTime) { return NativeCall<FString*, FString*, int>(nullptr, "UVictoryCore.FormatAsTimeLong(FString&,int)", result, InTime); }
	static bool CalculateInterceptPosition(const UE::Math::TVector<double>* StartPosition, const UE::Math::TVector<double>* StartVelocity, float ProjectileVelocity, const UE::Math::TVector<double>* TargetPosition, const UE::Math::TVector<double>* TargetVelocity, UE::Math::TVector<double>* InterceptPosition) { return NativeCall<bool, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*, float, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*, UE::Math::TVector<double>*>(nullptr, "UVictoryCore.CalculateInterceptPosition(UE::Math::TVector<double>*,UE::Math::TVector<double>*,float,UE::Math::TVector<double>*,UE::Math::TVector<double>*,UE::Math::TVector<double>*)", StartPosition, StartVelocity, ProjectileVelocity, TargetPosition, TargetVelocity, InterceptPosition); }
	static int GetSecondsIntoDay() { return NativeCall<int>(nullptr, "UVictoryCore.GetSecondsIntoDay()"); }
	static bool GetGroundLocation(UObject* WorldContextObject, UE::Math::TVector<double>* theGroundLoc, const UE::Math::TVector<double>* StartLoc, const UE::Math::TVector<double>* OffsetUp, const UE::Math::TVector<double>* OffsetDown) { return NativeCall<bool, UObject*, UE::Math::TVector<double>*, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*>(nullptr, "UVictoryCore.GetGroundLocation(UObject*,UE::Math::TVector<double>*,UE::Math::TVector<double>*,UE::Math::TVector<double>*,UE::Math::TVector<double>*)", WorldContextObject, theGroundLoc, StartLoc, OffsetUp, OffsetDown); }
	static void CallGlobalLevelEvent(UObject* WorldContextObject, FName EventName) { NativeCall<void, UObject*, FName>(nullptr, "UVictoryCore.CallGlobalLevelEvent(UObject*,FName)", WorldContextObject, EventName); }
	static void StopAllMusicTracks(const UObject* WorldContextObject) { NativeCall<void, const UObject*>(nullptr, "UVictoryCore.StopAllMusicTracks(UObject*)", WorldContextObject); }
	static TArray<AActor*, TSizedDefaultAllocator<32> >* ServerOctreeOverlapActors() { return NativeCall<TArray<AActor*, TSizedDefaultAllocator<32> >*>(nullptr, "UVictoryCore.ServerOctreeOverlapActors()"); }
	static TArray<AActor*, TSizedDefaultAllocator<32> >* ServerOctreeOverlapActorsClass() { return NativeCall<TArray<AActor*, TSizedDefaultAllocator<32> >*>(nullptr, "UVictoryCore.ServerOctreeOverlapActorsClass()"); }
	static bool IsVerboseDisplayEnabled(const UObject* WorldContextObject) { return NativeCall<bool, const UObject*>(nullptr, "UVictoryCore.IsVerboseDisplayEnabled(UObject*)", WorldContextObject); }
	static AActor* SpawnActorDeferred(UClass* Class, UObject* WorldContextObject, const UE::Math::TVector<double>* Location, const UE::Math::TRotator<double>* Rotation, AActor* Owner, APawn* Instigator, bool bNoCollisionFail) { return NativeCall<AActor*, UClass*, UObject*, const UE::Math::TVector<double>*, const UE::Math::TRotator<double>*, AActor*, APawn*, bool>(nullptr, "UVictoryCore.SpawnActorDeferred(UClass*,UObject*,UE::Math::TVector<double>*,UE::Math::TRotator<double>*,AActor*,APawn*,bool)", Class, WorldContextObject, Location, Rotation, Owner, Instigator, bNoCollisionFail); }
	static void FinishSpawning(AActor* Actor) { NativeCall<void, AActor*>(nullptr, "UVictoryCore.FinishSpawning(AActor*)", Actor); }
	static bool KillTargetCharacterOrStructure(AActor* ActorToKill, AActor* DamageCauser, bool bTryDestroyActor) { return NativeCall<bool, AActor*, AActor*, bool>(nullptr, "UVictoryCore.KillTargetCharacterOrStructure(AActor*,AActor*,bool)", ActorToKill, DamageCauser, bTryDestroyActor); }
	static __int64 GetWeightedRandomIndexFromArray() { return NativeCall<__int64>(nullptr, "UVictoryCore.GetWeightedRandomIndexFromArray()"); }
	static AActor* GetClosestActorArray() { return NativeCall<AActor*>(nullptr, "UVictoryCore.GetClosestActorArray()"); }
	static void GetSpecialActorList(UObject* WorldContextObject, TEnumAsByte<enum EActorListsBP::Type> ActorListType, TArray<AActor*, TSizedDefaultAllocator<32> >* OutActors) { NativeCall<void, UObject*, TEnumAsByte<enum EActorListsBP::Type>, TArray<AActor*, TSizedDefaultAllocator<32> >*>(nullptr, "UVictoryCore.GetSpecialActorList(UObject*,TEnumAsByte<enumEActorListsBP::Type>,TArray<AActor*,TSizedDefaultAllocator<32>>*)", WorldContextObject, ActorListType, OutActors); }
	static ACustomActorList* GetCustomActorList(UObject* WorldContextObject, FName SearchCustomTag) { return NativeCall<ACustomActorList*, UObject*, FName>(nullptr, "UVictoryCore.GetCustomActorList(UObject*,FName)", WorldContextObject, SearchCustomTag); }
	static long double GetNetworkTimeInSeconds(UObject* WorldContextObject) { return NativeCall<long double, UObject*>(nullptr, "UVictoryCore.GetNetworkTimeInSeconds(UObject*)", WorldContextObject); }
	static long double GetRealWorldUtcTimeInSeconds() { return NativeCall<long double>(nullptr, "UVictoryCore.GetRealWorldUtcTimeInSeconds()"); }
	static long double NetworkTimeToRealWorldUtcTime(UObject* WorldContextObject, long double NetworkTime) { return NativeCall<long double, UObject*, long double>(nullptr, "UVictoryCore.NetworkTimeToRealWorldUtcTime(UObject*,longdouble)", WorldContextObject, NetworkTime); }
	static TArray<APlayerCameraManager*, TSizedDefaultAllocator<32> >* GetAllLocalPlayerCameraManagers(TArray<APlayerCameraManager*, TSizedDefaultAllocator<32> >* result, UObject* WorldContextObject) { return NativeCall<TArray<APlayerCameraManager*, TSizedDefaultAllocator<32> >*, TArray<APlayerCameraManager*, TSizedDefaultAllocator<32> >*, UObject*>(nullptr, "UVictoryCore.GetAllLocalPlayerCameraManagers(TArray<APlayerCameraManager*,TSizedDefaultAllocator<32>>*,UObject*)", result, WorldContextObject); }
	static AShooterCharacter* GetShooterCharacterFromPawn(APawn* Pawn) { return NativeCall<AShooterCharacter*, APawn*>(nullptr, "UVictoryCore.GetShooterCharacterFromPawn(APawn*)", Pawn); }
	static AShooterCharacter* GetShooterCharacterFromController(AController* Controller) { return NativeCall<AShooterCharacter*, AController*>(nullptr, "UVictoryCore.GetShooterCharacterFromController(AController*)", Controller); }
	static bool VTraceSingleBP(UObject* WorldContextObject, FHitResult* OutHit, const UE::Math::TVector<double>* Start, const UE::Math::TVector<double>* End, ECollisionChannel TraceChannel, int CollisionGroups, FName TraceTag, bool bTraceComplex, AActor* ActorToIgnore, float DebugDrawDuration) { return NativeCall<bool, UObject*, FHitResult*, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*, ECollisionChannel, int, FName, bool, AActor*, float>(nullptr, "UVictoryCore.VTraceSingleBP(UObject*,FHitResult*,UE::Math::TVector<double>*,UE::Math::TVector<double>*,ECollisionChannel,int,FName,bool,AActor*,float)", WorldContextObject, OutHit, Start, End, TraceChannel, CollisionGroups, TraceTag, bTraceComplex, ActorToIgnore, DebugDrawDuration); }
	static bool VTraceSingleBP_IgnoreActorsArray(UObject* WorldContextObject, FHitResult* OutHit, const UE::Math::TVector<double>* Start, const UE::Math::TVector<double>* End, const TArray<AActor*, TSizedDefaultAllocator<32> >* ExtraIgnoreActors, const AActor* InIgnoreActor, ECollisionChannel TraceChannel, int CollisionGroups, FName TraceTag, bool bReturnPhysMaterial, bool bTraceComplex, float DebugDrawDuration) { return NativeCall<bool, UObject*, FHitResult*, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*, const TArray<AActor*, TSizedDefaultAllocator<32> >*, const AActor*, ECollisionChannel, int, FName, bool, bool, float>(nullptr, "UVictoryCore.VTraceSingleBP_IgnoreActorsArray(UObject*,FHitResult*,UE::Math::TVector<double>*,UE::Math::TVector<double>*,TArray<AActor*,TSizedDefaultAllocator<32>>*,AActor*,ECollisionChannel,int,FName,bool,bool,float)", WorldContextObject, OutHit, Start, End, ExtraIgnoreActors, InIgnoreActor, TraceChannel, CollisionGroups, TraceTag, bReturnPhysMaterial, bTraceComplex, DebugDrawDuration); }
	static bool VTraceSphereBP(UObject* WorldContextObject, const UE::Math::TVector<double>* Start, const UE::Math::TVector<double>* End, FHitResult* HitOut, float Radius, const AActor* ActorToIgnore, ECollisionChannel Channel, int CollisionGroups, bool bReturnPhysMaterial, bool bTraceComplex, FName TraceTag, const AActor* OtherActorToIgnore, AActor* AnotherActorToIgnore, float DebugDrawDuration) { return NativeCall<bool, UObject*, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*, FHitResult*, float, const AActor*, ECollisionChannel, int, bool, bool, FName, const AActor*, AActor*, float>(nullptr, "UVictoryCore.VTraceSphereBP(UObject*,UE::Math::TVector<double>*,UE::Math::TVector<double>*,FHitResult*,float,AActor*,ECollisionChannel,int,bool,bool,FName,AActor*,AActor*,float)", WorldContextObject, Start, End, HitOut, Radius, ActorToIgnore, Channel, CollisionGroups, bReturnPhysMaterial, bTraceComplex, TraceTag, OtherActorToIgnore, AnotherActorToIgnore, DebugDrawDuration); }
	static bool VTraceSphereBP_IgnoreActorsArray(UObject* WorldContextObject, const UE::Math::TVector<double>* Start, const UE::Math::TVector<double>* End, FHitResult* HitOut, float Radius, const TArray<AActor*, TSizedDefaultAllocator<32> >* ExtraIgnoreActors, const AActor* InIgnoreActor, ECollisionChannel Channel, int CollisionGroups, bool bReturnPhysMaterial, bool bTraceComplex, FName TraceTag, float DebugDrawDuration) { return NativeCall<bool, UObject*, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*, FHitResult*, float, const TArray<AActor*, TSizedDefaultAllocator<32> >*, const AActor*, ECollisionChannel, int, bool, bool, FName, float>(nullptr, "UVictoryCore.VTraceSphereBP_IgnoreActorsArray(UObject*,UE::Math::TVector<double>*,UE::Math::TVector<double>*,FHitResult*,float,TArray<AActor*,TSizedDefaultAllocator<32>>*,AActor*,ECollisionChannel,int,bool,bool,FName,float)", WorldContextObject, Start, End, HitOut, Radius, ExtraIgnoreActors, InIgnoreActor, Channel, CollisionGroups, bReturnPhysMaterial, bTraceComplex, TraceTag, DebugDrawDuration); }
	static bool VTraceShapeBP() { return NativeCall<bool>(nullptr, "UVictoryCore.VTraceShapeBP()"); }
	static bool VTraceShapeMultiBP() { return NativeCall<bool>(nullptr, "UVictoryCore.VTraceShapeMultiBP()"); }
	static bool VTraceMulti(UWorld* theWorld, TArray<FHitResult, TSizedDefaultAllocator<32> >* OutHits, const UE::Math::TVector<double>* Start, const UE::Math::TVector<double>* End, AActor* InIgnoreActor, int CollisionGroups, float SphereRadius, const UE::Math::TVector<double>* BoxExtent, bool bReturnPhysMaterial, ECollisionChannel TraceChannel, bool bTraceComplex, FName TraceTag, bool bTraceChannelForceOverlap, bool bDoSort, AActor* AdditionalIgnoreActor, AActor* AnotherIgnoreActor, bool bJustDoSphereOverlapAtStartLoc, TArray<AActor*, TSizedDefaultAllocator<32> >* ExtraIgnoreActors) { return NativeCall<bool, UWorld*, TArray<FHitResult, TSizedDefaultAllocator<32> >*, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*, AActor*, int, float, const UE::Math::TVector<double>*, bool, ECollisionChannel, bool, FName, bool, bool, AActor*, AActor*, bool, TArray<AActor*, TSizedDefaultAllocator<32> >*>(nullptr, "UVictoryCore.VTraceMulti(UWorld*,TArray<FHitResult,TSizedDefaultAllocator<32>>*,UE::Math::TVector<double>*,UE::Math::TVector<double>*,AActor*,int,float,UE::Math::TVector<double>*,bool,ECollisionChannel,bool,FName,bool,bool,AActor*,AActor*,bool,TArray<AActor*,TSizedDefaultAllocator<32>>*)", theWorld, OutHits, Start, End, InIgnoreActor, CollisionGroups, SphereRadius, BoxExtent, bReturnPhysMaterial, TraceChannel, bTraceComplex, TraceTag, bTraceChannelForceOverlap, bDoSort, AdditionalIgnoreActor, AnotherIgnoreActor, bJustDoSphereOverlapAtStartLoc, ExtraIgnoreActors); }
	static bool VTraceMultiBP(UObject* WorldContextObject, TArray<FHitResult, TSizedDefaultAllocator<32> >* OutHits, const UE::Math::TVector<double>* Start, const UE::Math::TVector<double>* End, AActor* InIgnoreActor, int CollisionGroups, float SphereRadius, const UE::Math::TVector<double>* BoxExtent, bool bReturnPhysMaterial, ECollisionChannel TraceChannel, bool bTraceComplex, FName TraceTag, bool bTraceChannelForceOverlap, bool bDoSort, AActor* AdditionalIgnoreActor, AActor* AnotherIgnoreActor, bool bJustDoSphereOverlapAtStartLoc, float DebugDrawDuration) { return NativeCall<bool, UObject*, TArray<FHitResult, TSizedDefaultAllocator<32> >*, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*, AActor*, int, float, const UE::Math::TVector<double>*, bool, ECollisionChannel, bool, FName, bool, bool, AActor*, AActor*, bool, float>(nullptr, "UVictoryCore.VTraceMultiBP(UObject*,TArray<FHitResult,TSizedDefaultAllocator<32>>*,UE::Math::TVector<double>*,UE::Math::TVector<double>*,AActor*,int,float,UE::Math::TVector<double>*,bool,ECollisionChannel,bool,FName,bool,bool,AActor*,AActor*,bool,float)", WorldContextObject, OutHits, Start, End, InIgnoreActor, CollisionGroups, SphereRadius, BoxExtent, bReturnPhysMaterial, TraceChannel, bTraceComplex, TraceTag, bTraceChannelForceOverlap, bDoSort, AdditionalIgnoreActor, AnotherIgnoreActor, bJustDoSphereOverlapAtStartLoc, DebugDrawDuration); }
	static bool VTraceMultiBP_IgnoreActorsArray(UObject* WorldContextObject, TArray<FHitResult, TSizedDefaultAllocator<32> >* OutHits, const UE::Math::TVector<double>* Start, const UE::Math::TVector<double>* End, const TArray<AActor*, TSizedDefaultAllocator<32> >* ExtraIgnoreActors, AActor* InIgnoreActor, int CollisionGroups, float SphereRadius, const UE::Math::TVector<double>* BoxExtent, bool bReturnPhysMaterial, ECollisionChannel TraceChannel, bool bTraceComplex, FName TraceTag, bool bTraceChannelForceOverlap, bool bDoSort, bool bJustDoSphereOverlapAtStartLoc, float DebugDrawDuration) { return NativeCall<bool, UObject*, TArray<FHitResult, TSizedDefaultAllocator<32> >*, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*, const TArray<AActor*, TSizedDefaultAllocator<32> >*, AActor*, int, float, const UE::Math::TVector<double>*, bool, ECollisionChannel, bool, FName, bool, bool, bool, float>(nullptr, "UVictoryCore.VTraceMultiBP_IgnoreActorsArray(UObject*,TArray<FHitResult,TSizedDefaultAllocator<32>>*,UE::Math::TVector<double>*,UE::Math::TVector<double>*,TArray<AActor*,TSizedDefaultAllocator<32>>*,AActor*,int,float,UE::Math::TVector<double>*,bool,ECollisionChannel,bool,FName,bool,bool,bool,float)", WorldContextObject, OutHits, Start, End, ExtraIgnoreActors, InIgnoreActor, CollisionGroups, SphereRadius, BoxExtent, bReturnPhysMaterial, TraceChannel, bTraceComplex, TraceTag, bTraceChannelForceOverlap, bDoSort, bJustDoSphereOverlapAtStartLoc, DebugDrawDuration); }
	static bool IsGamePadConnected() { return NativeCall<bool>(nullptr, "UVictoryCore.IsGamePadConnected()"); }
	static int IsChildOfClasses(TSubclassOf<UObject> childClass, const TArray<TSubclassOf<UObject>, TSizedDefaultAllocator<32> >* ParentClassesArray) { return NativeCall<int, TSubclassOf<UObject>, const TArray<TSubclassOf<UObject>, TSizedDefaultAllocator<32> >*>(nullptr, "UVictoryCore.IsChildOfClasses(TSubclassOf<UObject>,TArray<TSubclassOf<UObject>,TSizedDefaultAllocator<32>>*)", childClass, ParentClassesArray); }
	static bool ObjectIsChildOfSoftRef() { return NativeCall<bool>(nullptr, "UVictoryCore.ObjectIsChildOfSoftRef()"); }
	static bool IsPVEServer(UObject* WorldContextObject) { return NativeCall<bool, UObject*>(nullptr, "UVictoryCore.IsPVEServer(UObject*)", WorldContextObject); }
	static bool IsTimeSince_Network(UObject* WorldContextObject, long double OldTime, float CheckTimeSince, bool bForceTrueAtZeroTime) { return NativeCall<bool, UObject*, long double, float, bool>(nullptr, "UVictoryCore.IsTimeSince_Network(UObject*,longdouble,float,bool)", WorldContextObject, OldTime, CheckTimeSince, bForceTrueAtZeroTime); }
	static bool IsTimeSince_Utc(long double OldTime, float CheckTimeSince, bool bForceTrueAtZeroTime) { return NativeCall<bool, long double, float, bool>(nullptr, "UVictoryCore.IsTimeSince_Utc(longdouble,float,bool)", OldTime, CheckTimeSince, bForceTrueAtZeroTime); }
	static float TimeSince_Network(UObject* WorldContextObject, long double OldTime) { return NativeCall<float, UObject*, long double>(nullptr, "UVictoryCore.TimeSince_Network(UObject*,longdouble)", WorldContextObject, OldTime); }
	static bool IsTimeSince(UObject* WorldContextObject, long double OldTime, float CheckTimeSince, bool bForceTrueAtZeroTime) { return NativeCall<bool, UObject*, long double, float, bool>(nullptr, "UVictoryCore.IsTimeSince(UObject*,longdouble,float,bool)", WorldContextObject, OldTime, CheckTimeSince, bForceTrueAtZeroTime); }
	static float TimeSince(UObject* WorldContextObject, long double OldTime) { return NativeCall<float, UObject*, long double>(nullptr, "UVictoryCore.TimeSince(UObject*,longdouble)", WorldContextObject, OldTime); }
	static FString* LeaderboardColumnNameToString(FString* result, TEnumAsByte<enum ELeaderboardColumnName::Type> ColumnType) { return NativeCall<FString*, FString*, TEnumAsByte<enum ELeaderboardColumnName::Type>>(nullptr, "UVictoryCore.LeaderboardColumnNameToString(FString&,TEnumAsByte<enumELeaderboardColumnName::Type>)", result, ColumnType); }
	static void PauseTimer() { NativeCall<void>(nullptr, "UVictoryCore.PauseTimer()"); }
	static void UnPauseTimer() { NativeCall<void>(nullptr, "UVictoryCore.UnPauseTimer()"); }
	static bool IsTimerActive() { return NativeCall<bool>(nullptr, "UVictoryCore.IsTimerActive()"); }
	static bool IsTimerPaused() { return NativeCall<bool>(nullptr, "UVictoryCore.IsTimerPaused()"); }
	static FString* GetLastMapPlayed(FString* result) { return NativeCall<FString*, FString*>(nullptr, "UVictoryCore.GetLastMapPlayed(FString&)", result); }
	static void SetLastMapPlayed(const FString* NewLastMapPlayed) { NativeCall<void, const FString*>(nullptr, "UVictoryCore.SetLastMapPlayed(FString&)", NewLastMapPlayed); }
	static FString* GetLastHostedMapPlayed(FString* result) { return NativeCall<FString*, FString*>(nullptr, "UVictoryCore.GetLastHostedMapPlayed(FString&)", result); }
	static void SetLastHostedMapPlayed(const FString* NewLastHostedMapPlayed) { NativeCall<void, const FString*>(nullptr, "UVictoryCore.SetLastHostedMapPlayed(FString&)", NewLastHostedMapPlayed); }
	static bool OwnsScorchedEarth() { return NativeCall<bool>(nullptr, "UVictoryCore.OwnsScorchedEarth()"); }
	static bool OwnsAberration() { return NativeCall<bool>(nullptr, "UVictoryCore.OwnsAberration()"); }
	static bool OwnsExtinction() { return NativeCall<bool>(nullptr, "UVictoryCore.OwnsExtinction()"); }
	static bool OwnsGenesisSeasonPass() { return NativeCall<bool>(nullptr, "UVictoryCore.OwnsGenesisSeasonPass()"); }
	static bool OwnsGenesis() { return NativeCall<bool>(nullptr, "UVictoryCore.OwnsGenesis()"); }
	static bool IsEngramGroupAllowed(AShooterPlayerController* forPC, int EngramGroup) { return NativeCall<bool, AShooterPlayerController*, int>(nullptr, "UVictoryCore.IsEngramGroupAllowed(AShooterPlayerController*,int)", forPC, EngramGroup); }
	static bool DoesOwnSelectedDLC(EDLCSelector SelectedDLC) { return NativeCall<bool, EDLCSelector>(nullptr, "UVictoryCore.DoesOwnSelectedDLC(EDLCSelector)", SelectedDLC); }
	static FString* GetDLCNameFromSelector(FString* result, EDLCSelector SelectedDLC) { return NativeCall<FString*, FString*, EDLCSelector>(nullptr, "UVictoryCore.GetDLCNameFromSelector(FString&,EDLCSelector)", result, SelectedDLC); }
	static void OpenStorePageForDLC() { NativeCall<void>(nullptr, "UVictoryCore.OpenStorePageForDLC()"); }
	static TArray<AActor*, TSizedDefaultAllocator<32> >* SortActorsByDistance(TArray<AActor*, TSizedDefaultAllocator<32> >* result, const UE::Math::TVector<double>* fromLoc, const TArray<AActor*, TSizedDefaultAllocator<32> >* actors) { return NativeCall<TArray<AActor*, TSizedDefaultAllocator<32> >*, TArray<AActor*, TSizedDefaultAllocator<32> >*, const UE::Math::TVector<double>*, const TArray<AActor*, TSizedDefaultAllocator<32> >*>(nullptr, "UVictoryCore.SortActorsByDistance(TArray<AActor*,TSizedDefaultAllocator<32>>*,UE::Math::TVector<double>*,TArray<AActor*,TSizedDefaultAllocator<32>>*)", result, fromLoc, actors); }
	static void PlayMusic() { NativeCall<void>(nullptr, "UVictoryCore.PlayMusic()"); }
	static void StopMusic() { NativeCall<void>(nullptr, "UVictoryCore.StopMusic()"); }
	static UClass* BPLoadClass(const FString* PathName) { return NativeCall<UClass*, const FString*>(nullptr, "UVictoryCore.BPLoadClass(FString&)", PathName); }
	static bool VTraceAgainstActorExpensive(UObject* WorldContextObject, const UE::Math::TVector<double>* Start, const UE::Math::TVector<double>* End, FHitResult* HitOut, AActor* ActorToTraceAgainst, ECollisionChannel Channel, __int64 CollisionGroups, float SphereRadius, bool bReturnPhysMaterial, bool bTraceComplex, const UE::Math::TVector<double>* BoxExtent, FName TraceTag, bool bSort) { return NativeCall<bool, UObject*, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*, FHitResult*, AActor*, ECollisionChannel, __int64, float, bool, bool, const UE::Math::TVector<double>*, FName, bool>(nullptr, "UVictoryCore.VTraceAgainstActorExpensive(UObject*,UE::Math::TVector<double>*,UE::Math::TVector<double>*,FHitResult*,AActor*,ECollisionChannel,__int64,float,bool,bool,UE::Math::TVector<double>*,FName,bool)", WorldContextObject, Start, End, HitOut, ActorToTraceAgainst, Channel, CollisionGroups, SphereRadius, bReturnPhysMaterial, bTraceComplex, BoxExtent, TraceTag, bSort); }
	static TSubclassOf<UObject>* StringReferenceToClass(TSubclassOf<UObject>* result, const FString* StringReference) { return NativeCall<TSubclassOf<UObject> *, TSubclassOf<UObject>*, const FString*>(nullptr, "UVictoryCore.StringReferenceToClass(TSubclassOf<UObject>*,FString&)", result, StringReference); }
	static void RefreshApplySoundVolumes() { NativeCall<void>(nullptr, "UVictoryCore.RefreshApplySoundVolumes()"); }
	static void RefreshApplySoundAndMusicVolumes() { NativeCall<void>(nullptr, "UVictoryCore.RefreshApplySoundAndMusicVolumes()"); }
	static FString* GetTwoLetterISOLanguageName(FString* result) { return NativeCall<FString*, FString*>(nullptr, "UVictoryCore.GetTwoLetterISOLanguageName(FString&)", result); }
	static FString* GetSoundWaveLocalizedSpokenText(FString* result, USoundWave* inSound) { return NativeCall<FString*, FString*, USoundWave*>(nullptr, "UVictoryCore.GetSoundWaveLocalizedSpokenText(FString&,USoundWave*)", result, inSound); }
	static FString* GetSoundCueLocalizedSpokenText(FString* result, USoundCue* inSound) { return NativeCall<FString*, FString*, USoundCue*>(nullptr, "UVictoryCore.GetSoundCueLocalizedSpokenText(FString&,USoundCue*)", result, inSound); }
	static bool GetLocaleSpecificAudio(const TArray<FLocalizedSoundCueEntry, TSizedDefaultAllocator<32> >* LocalizedSoundCues, FLocalizedSoundCueEntry* OutLocalizedAudio, const FString* LanguageOverride) { return NativeCall<bool, const TArray<FLocalizedSoundCueEntry, TSizedDefaultAllocator<32> >*, FLocalizedSoundCueEntry*, const FString*>(nullptr, "UVictoryCore.GetLocaleSpecificAudio(TArray<FLocalizedSoundCueEntry,TSizedDefaultAllocator<32>>*,FLocalizedSoundCueEntry*,FString&)", LocalizedSoundCues, OutLocalizedAudio, LanguageOverride); }
	static bool GetLocaleSpecificSoundWaveAnimTexturePairArrays(const TArray<FLocalizedSoundWaveAnimTexturePairArrays, TSizedDefaultAllocator<32> >* LocalizedSoundWaveAnimTextures, FLocalizedSoundWaveAnimTexturePairArrays* OutLocalizedAudio, bool* FoundLocalizedSoundWavesForThisLanguage, const FString* LanguageOverride) { return NativeCall<bool, const TArray<FLocalizedSoundWaveAnimTexturePairArrays, TSizedDefaultAllocator<32> >*, FLocalizedSoundWaveAnimTexturePairArrays*, bool*, const FString*>(nullptr, "UVictoryCore.GetLocaleSpecificSoundWaveAnimTexturePairArrays(TArray<FLocalizedSoundWaveAnimTexturePairArrays,TSizedDefaultAllocator<32>>*,FLocalizedSoundWaveAnimTexturePairArrays*,bool*,FString&)", LocalizedSoundWaveAnimTextures, OutLocalizedAudio, FoundLocalizedSoundWavesForThisLanguage, LanguageOverride); }
	static FString* FindLocalizedVersionOfFilename(FString* result, const FSoftObjectPath* OriginalFile) { return NativeCall<FString*, FString*, const FSoftObjectPath*>(nullptr, "UVictoryCore.FindLocalizedVersionOfFilename(FString&,FSoftObjectPath*)", result, OriginalFile); }
	static void AddEnvironmentInteractionEffect() { NativeCall<void>(nullptr, "UVictoryCore.AddEnvironmentInteractionEffect()"); }
	static void AddEnvironmentCapsuleInteractionEffect() { NativeCall<void>(nullptr, "UVictoryCore.AddEnvironmentCapsuleInteractionEffect()"); }
	static void AddFluidInteraction() { NativeCall<void>(nullptr, "UVictoryCore.AddFluidInteraction()"); }
	static char IsLocationLikelyWithinAnIncorrectlyPlacedWaterVolume() { return NativeCall<char>(nullptr, "UVictoryCore.IsLocationLikelyWithinAnIncorrectlyPlacedWaterVolume()"); }
	static FString* GetTotalCoversionIdAsString(FString* result) { return NativeCall<FString*, FString*>(nullptr, "UVictoryCore.GetTotalCoversionIdAsString(FString&)", result); }
	static UClass* GetItemClassFromItemSetup(const FItemSetup* ItemSetup) { return NativeCall<UClass*, const FItemSetup*>(nullptr, "UVictoryCore.GetItemClassFromItemSetup(FItemSetup*)", ItemSetup); }
	static bool GetCharacterCapsuleSize(TSubclassOf<APrimalCharacter> CharClass, float* OutCapsuleRadius, float* OutCapsuleHalfHeight) { return NativeCall<bool, TSubclassOf<APrimalCharacter>, float*, float*>(nullptr, "UVictoryCore.GetCharacterCapsuleSize(TSubclassOf<APrimalCharacter>,float*,float*)", CharClass, OutCapsuleRadius, OutCapsuleHalfHeight); }
	static UClass* GetDinoStaticClass(const FDinoSetup* DinoSetup) { return NativeCall<UClass*, const FDinoSetup*>(nullptr, "UVictoryCore.GetDinoStaticClass(FDinoSetup*)", DinoSetup); }
	static APrimalDinoCharacter* SpawnCustomDino(UObject* WorldContextObject, const UE::Math::TVector<double>* SpawnLocation, const UE::Math::TRotator<double>* SpawnRotation, const FDinoSetup* DinoSetup, AShooterPlayerController* OwnerPlayerController, float DebugDrawDuration, bool bApplyRotationToSpawnOffset, bool bUseExactSpawnLocation, bool bSkipAddingTamedLevels, bool bSuppressTamingNotifications, AMissionType* mission, TSubclassOf<UPrimalColorSet> ColorSet) { return NativeCall<APrimalDinoCharacter*, UObject*, const UE::Math::TVector<double>*, const UE::Math::TRotator<double>*, const FDinoSetup*, AShooterPlayerController*, float, bool, bool, bool, bool, AMissionType*, TSubclassOf<UPrimalColorSet>>(nullptr, "UVictoryCore.SpawnCustomDino(UObject*,UE::Math::TVector<double>*,UE::Math::TRotator<double>*,FDinoSetup*,AShooterPlayerController*,float,bool,bool,bool,bool,AMissionType*,TSubclassOf<UPrimalColorSet>)", WorldContextObject, SpawnLocation, SpawnRotation, DinoSetup, OwnerPlayerController, DebugDrawDuration, bApplyRotationToSpawnOffset, bUseExactSpawnLocation, bSkipAddingTamedLevels, bSuppressTamingNotifications, mission, ColorSet); }
	static bool CanSpawnCustomDino(UObject* WorldContextObject, UE::Math::TVector<double>* OutCalculatedSpawnLocation, const UE::Math::TVector<double>* PlayerLocation, const UE::Math::TVector<double>* SpawnLocation, const UE::Math::TRotator<double>* SpawnRotation, const FDinoSetup* DinoSetup, float DebugDrawDuration, bool bDoLosCheck, bool bDoExtraSafetyChecks, APrimalCharacter* spawningCharacter, bool bDoOverlapCheck) { return NativeCall<bool, UObject*, UE::Math::TVector<double>*, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*, const UE::Math::TRotator<double>*, const FDinoSetup*, float, bool, bool, APrimalCharacter*, bool>(nullptr, "UVictoryCore.CanSpawnCustomDino(UObject*,UE::Math::TVector<double>*,UE::Math::TVector<double>*,UE::Math::TVector<double>*,UE::Math::TRotator<double>*,FDinoSetup*,float,bool,bool,APrimalCharacter*,bool)", WorldContextObject, OutCalculatedSpawnLocation, PlayerLocation, SpawnLocation, SpawnRotation, DinoSetup, DebugDrawDuration, bDoLosCheck, bDoExtraSafetyChecks, spawningCharacter, bDoOverlapCheck); }
	static int CountCharactersResolvingGroundLocationInSphere(UWorld* WorldContext, const UE::Math::TVector<double>* location, float radius) { return NativeCall<int, UWorld*, const UE::Math::TVector<double>*, float>(nullptr, "UVictoryCore.CountCharactersResolvingGroundLocationInSphere(UWorld*,UE::Math::TVector<double>*,float)", WorldContext, location, radius); }
	static bool GetDinoSetupGroup_ByName(FName GroupName, const TArray<FDinoSetupGroup, TSizedDefaultAllocator<32> >* DinoSetupGroups, FDinoSetupGroup* OutGroup) { return NativeCall<bool, FName, const TArray<FDinoSetupGroup, TSizedDefaultAllocator<32> >*, FDinoSetupGroup*>(nullptr, "UVictoryCore.GetDinoSetupGroup_ByName(FName,TArray<FDinoSetupGroup,TSizedDefaultAllocator<32>>*,FDinoSetupGroup*)", GroupName, DinoSetupGroups, OutGroup); }
	static bool GetDinoSetupGroup_WeightedRandom(const TArray<FDinoSetupGroup, TSizedDefaultAllocator<32> >* DinoSetupGroups, FDinoSetupGroup* OutGroup) { return NativeCall<bool, const TArray<FDinoSetupGroup, TSizedDefaultAllocator<32> >*, FDinoSetupGroup*>(nullptr, "UVictoryCore.GetDinoSetupGroup_WeightedRandom(TArray<FDinoSetupGroup,TSizedDefaultAllocator<32>>*,FDinoSetupGroup*)", DinoSetupGroups, OutGroup); }
	static void ForEachAvailableMissionType(UWorld* World, const TFunction<bool __cdecl(FAvailableMission const&)>* Callback) { NativeCall<void, UWorld*, const TFunction<bool __cdecl(FAvailableMission const&)>*>(nullptr, "UVictoryCore.ForEachAvailableMissionType(UWorld*,TFunction<bool__cdecl(FAvailableMission&)>*)", World, Callback); }
	static TArray<FAvailableMission, TSizedDefaultAllocator<32> >* GetAllAvailableMissions(TArray<FAvailableMission, TSizedDefaultAllocator<32> >* result, UObject* WorldContextObject) { return NativeCall<TArray<FAvailableMission, TSizedDefaultAllocator<32> >*, TArray<FAvailableMission, TSizedDefaultAllocator<32> >*, UObject*>(nullptr, "UVictoryCore.GetAllAvailableMissions(TArray<FAvailableMission,TSizedDefaultAllocator<32>>*,UObject*)", result, WorldContextObject); }
	static TArray<FName, TSizedDefaultAllocator<32> >* GetAllAvailableMissionsAsTags(TArray<FName, TSizedDefaultAllocator<32> >* result, UObject* WorldContextObject) { return NativeCall<TArray<FName, TSizedDefaultAllocator<32> >*, TArray<FName, TSizedDefaultAllocator<32> >*, UObject*>(nullptr, "UVictoryCore.GetAllAvailableMissionsAsTags(TArray<FName,TSizedDefaultAllocator<32>>*,UObject*)", result, WorldContextObject); }
	static TArray<AActor*, TSizedDefaultAllocator<32> >* GetAllMissionActors(TArray<AActor*, TSizedDefaultAllocator<32> >* result, UObject* WorldContextObject) { return NativeCall<TArray<AActor*, TSizedDefaultAllocator<32> >*, TArray<AActor*, TSizedDefaultAllocator<32> >*, UObject*>(nullptr, "UVictoryCore.GetAllMissionActors(TArray<AActor*,TSizedDefaultAllocator<32>>*,UObject*)", result, WorldContextObject); }
	static AActor* GetMissionActorOfType(UObject* WorldContextObject, TSubclassOf<AMissionType> theMissionType, bool bExactMatch) { return NativeCall<AActor*, UObject*, TSubclassOf<AMissionType>, bool>(nullptr, "UVictoryCore.GetMissionActorOfType(UObject*,TSubclassOf<AMissionType>,bool)", WorldContextObject, theMissionType, bExactMatch); }
	static TArray<AActor*, TSizedDefaultAllocator<32> >* GetAllMissionDispatchers(TArray<AActor*, TSizedDefaultAllocator<32> >* result, UObject* WorldContextObject) { return NativeCall<TArray<AActor*, TSizedDefaultAllocator<32> >*, TArray<AActor*, TSizedDefaultAllocator<32> >*, UObject*>(nullptr, "UVictoryCore.GetAllMissionDispatchers(TArray<AActor*,TSizedDefaultAllocator<32>>*,UObject*)", result, WorldContextObject); }
	static TArray<AActor*, TSizedDefaultAllocator<32> >* GetAllMissionDispatcherPoints(TArray<AActor*, TSizedDefaultAllocator<32> >* result, UObject* WorldContextObject) { return NativeCall<TArray<AActor*, TSizedDefaultAllocator<32> >*, TArray<AActor*, TSizedDefaultAllocator<32> >*, UObject*>(nullptr, "UVictoryCore.GetAllMissionDispatcherPoints(TArray<AActor*,TSizedDefaultAllocator<32>>*,UObject*)", result, WorldContextObject); }
	static TSubclassOf<UPrimalItem>* GenerateRandomLootItem(TSubclassOf<UPrimalItem>* result, TEnumAsByte<enum ELootItemType::Type> LootItemType) { return NativeCall<TSubclassOf<UPrimalItem> *, TSubclassOf<UPrimalItem>*, TEnumAsByte<enum ELootItemType::Type>>(nullptr, "UVictoryCore.GenerateRandomLootItem(TSubclassOf<UPrimalItem>*,TEnumAsByte<enumELootItemType::Type>)", result, LootItemType); }
	static TSubclassOf<UPrimalItem>* GenerateRandomLootItemFromLootTable(TSubclassOf<UPrimalItem>* result, const TArray<FLootTableEntry, TSizedDefaultAllocator<32> >* Entries, int* OutItemQuantity, float* OutItemQuality) { return NativeCall<TSubclassOf<UPrimalItem> *, TSubclassOf<UPrimalItem>*, const TArray<FLootTableEntry, TSizedDefaultAllocator<32> >*, int*, float*>(nullptr, "UVictoryCore.GenerateRandomLootItemFromLootTable(TSubclassOf<UPrimalItem>*,TArray<FLootTableEntry,TSizedDefaultAllocator<32>>*,int*,float*)", result, Entries, OutItemQuantity, OutItemQuality); }
	static TArray<UPrimalItem*, TSizedDefaultAllocator<32> >* GiveItemToCharacter(TArray<UPrimalItem*, TSizedDefaultAllocator<32> >* result, APrimalCharacter* Character, TSubclassOf<UPrimalItem> ItemType, int NumItems, float Quality, bool bAutoEquip) { return NativeCall<TArray<UPrimalItem*, TSizedDefaultAllocator<32> >*, TArray<UPrimalItem*, TSizedDefaultAllocator<32> >*, APrimalCharacter*, TSubclassOf<UPrimalItem>, int, float, bool>(nullptr, "UVictoryCore.GiveItemToCharacter(TArray<UPrimalItem*,TSizedDefaultAllocator<32>>*,APrimalCharacter*,TSubclassOf<UPrimalItem>,int,float,bool)", result, Character, ItemType, NumItems, Quality, bAutoEquip); }
	static void GetObjectsReferencedBy(UObject* ForObject, TArray<UObject*, TSizedDefaultAllocator<32> >* OutReferencedObjects, bool bIgnoreTransient) { NativeCall<void, UObject*, TArray<UObject*, TSizedDefaultAllocator<32> >*, bool>(nullptr, "UVictoryCore.GetObjectsReferencedBy(UObject*,TArray<UObject*,TSizedDefaultAllocator<32>>*,bool)", ForObject, OutReferencedObjects, bIgnoreTransient); }
	static bool GetOverlappedHarvestActors(UObject* WorldContextObject, const UE::Math::TVector<double>* AtLoc, float AtRadius, TArray<AActor*, TSizedDefaultAllocator<32> >* OutHarvestActors, TArray<UActorComponent*, TSizedDefaultAllocator<32> >* OutHarvestComponents, TArray<UE::Math::TVector<double>, TSizedDefaultAllocator<32> >* OutHarvestLocations, TArray<int, TSizedDefaultAllocator<32> >* OutHitBodyIndices) { return NativeCall<bool, UObject*, const UE::Math::TVector<double>*, float, TArray<AActor*, TSizedDefaultAllocator<32> >*, TArray<UActorComponent*, TSizedDefaultAllocator<32> >*, TArray<UE::Math::TVector<double>, TSizedDefaultAllocator<32> >*, TArray<int, TSizedDefaultAllocator<32> >*>(nullptr, "UVictoryCore.GetOverlappedHarvestActors(UObject*,UE::Math::TVector<double>*,float,TArray<AActor*,TSizedDefaultAllocator<32>>*,TArray<UActorComponent*,TSizedDefaultAllocator<32>>*,TArray<UE::Math::TVector<double>,TSizedDefaultAllocator<32>>*,TArray<int,TSizedDefaultAllocator<32>>*)", WorldContextObject, AtLoc, AtRadius, OutHarvestActors, OutHarvestComponents, OutHarvestLocations, OutHitBodyIndices); }
	static void ServerSearchFoliage() { NativeCall<void>(nullptr, "UVictoryCore.ServerSearchFoliage()"); }
	static FName* GetHitBoneNameFromDamageEvent(FName* result, APrimalCharacter* Character, AController* HitInstigator, const FDamageEvent* DamageEvent, bool bIsPointDamage, const FHitResult* PointHitResult, FName MatchCollisionPresetName) { return NativeCall<FName*, FName*, APrimalCharacter*, AController*, const FDamageEvent*, bool, const FHitResult*, FName>(nullptr, "UVictoryCore.GetHitBoneNameFromDamageEvent(FName*,APrimalCharacter*,AController*,FDamageEvent*,bool,FHitResult*,FName)", result, Character, HitInstigator, DamageEvent, bIsPointDamage, PointHitResult, MatchCollisionPresetName); }
	static float GetAngleBetweenVectors(const UE::Math::TVector<double>* VectorA, const UE::Math::TVector<double>* VectorB, const UE::Math::TVector<double>* AroundAxis) { return NativeCall<float, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*, const UE::Math::TVector<double>*>(nullptr, "UVictoryCore.GetAngleBetweenVectors(UE::Math::TVector<double>*,UE::Math::TVector<double>*,UE::Math::TVector<double>*)", VectorA, VectorB, AroundAxis); }
	static float GetAngleBetweenVectorsPure() { return NativeCall<float>(nullptr, "UVictoryCore.GetAngleBetweenVectorsPure()"); }
	static bool AreRotatorsNearlyEqual(const UE::Math::TRotator<double>* RotatorA, const UE::Math::TRotator<double>* RotatorB, float WithinError) { return NativeCall<bool, const UE::Math::TRotator<double>*, const UE::Math::TRotator<double>*, float>(nullptr, "UVictoryCore.AreRotatorsNearlyEqual(UE::Math::TRotator<double>*,UE::Math::TRotator<double>*,float)", RotatorA, RotatorB, WithinError); }
	static bool AreTransformsNearlyEqual(const UE::Math::TTransform<double>* TransformA, const UE::Math::TTransform<double>* TransformB, float WithinError) { return NativeCall<bool, const UE::Math::TTransform<double>*, const UE::Math::TTransform<double>*, float>(nullptr, "UVictoryCore.AreTransformsNearlyEqual(UE::Math::TTransform<double>*,UE::Math::TTransform<double>*,float)", TransformA, TransformB, WithinError); }
	static void MulticastDrawDebugLine() { NativeCall<void>(nullptr, "UVictoryCore.MulticastDrawDebugLine()"); }
	static AShooterCharacter* GetPlayerCharacterByController(APlayerController* PC) { return NativeCall<AShooterCharacter*, APlayerController*>(nullptr, "UVictoryCore.GetPlayerCharacterByController(APlayerController*)", PC); }
	static APrimalDinoCharacter* GetDinoCharacterByID(UObject* WorldContextObject, const int DinoID1, const int DinoID2, const bool bSearchTamedOnly) { return NativeCall<APrimalDinoCharacter*, UObject*, const int, const int, const bool>(nullptr, "UVictoryCore.GetDinoCharacterByID(UObject*,int,int,bool)", WorldContextObject, DinoID1, DinoID2, bSearchTamedOnly); }
	static APrimalDinoCharacter* GetDinoCharacterByLongDinoID(UObject* WorldContextObject, const FString* DinoID, const bool bSearchTamedOnly) { return NativeCall<APrimalDinoCharacter*, UObject*, const FString*, const bool>(nullptr, "UVictoryCore.GetDinoCharacterByLongDinoID(UObject*,FString&,bool)", WorldContextObject, DinoID, bSearchTamedOnly); }
	static void GetAllClassesOfType() { NativeCall<void>(nullptr, "UVictoryCore.GetAllClassesOfType()"); }
	static bool IsValidItemForGrinding(const UPrimalItem* item, const UPrimalInventoryComponent* inventory) { return NativeCall<bool, const UPrimalItem*, const UPrimalInventoryComponent*>(nullptr, "UVictoryCore.IsValidItemForGrinding(UPrimalItem*,UPrimalInventoryComponent*)", item, inventory); }
	static bool GrindItemIntoInventory(UPrimalItem* item, UPrimalInventoryComponent* inventory, const bool bGrindStack, const int MaxQuantityToGrind, const float GrindGiveItemsPercent, const int MaxItemsToGivePerGrind) { return NativeCall<bool, UPrimalItem*, UPrimalInventoryComponent*, const bool, const int, const float, const int>(nullptr, "UVictoryCore.GrindItemIntoInventory(UPrimalItem*,UPrimalInventoryComponent*,bool,int,float,int)", item, inventory, bGrindStack, MaxQuantityToGrind, GrindGiveItemsPercent, MaxItemsToGivePerGrind); }
	static void GrindAllItemsToInventory(UPrimalInventoryComponent* inventory, const bool bGrindStack, const int MaxQuantityToGrind, const float GrindGiveItemsPercent, const int MaxItemsToGivePerGrind) { NativeCall<void, UPrimalInventoryComponent*, const bool, const int, const float, const int>(nullptr, "UVictoryCore.GrindAllItemsToInventory(UPrimalInventoryComponent*,bool,int,float,int)", inventory, bGrindStack, MaxQuantityToGrind, GrindGiveItemsPercent, MaxItemsToGivePerGrind); }
	static TSubclassOf<UPrimalItem>* GetGrinderReplacementItem(TSubclassOf<UPrimalItem>* result, TSubclassOf<UPrimalItem> current) { return NativeCall<TSubclassOf<UPrimalItem> *, TSubclassOf<UPrimalItem>*, TSubclassOf<UPrimalItem>>(nullptr, "UVictoryCore.GetGrinderReplacementItem(TSubclassOf<UPrimalItem>*,TSubclassOf<UPrimalItem>)", result, current); }
	static bool HasPlayerSeenGen2Intro(UObject* WorldContextObject) { return NativeCall<bool, UObject*>(nullptr, "UVictoryCore.HasPlayerSeenGen2Intro(UObject*)", WorldContextObject); }
	static void MarkGen2IntroAsSeen(UObject* WorldContextObject) { NativeCall<void, UObject*>(nullptr, "UVictoryCore.MarkGen2IntroAsSeen(UObject*)", WorldContextObject); }
	static void ForceScreenColorFade() { NativeCall<void>(nullptr, "UVictoryCore.ForceScreenColorFade()"); }
	static float GetScreenPercentage() { return NativeCall<float>(nullptr, "UVictoryCore.GetScreenPercentage()"); }
	static bool ProjectWorldToScreenPositionRaw() { return NativeCall<bool>(nullptr, "UVictoryCore.ProjectWorldToScreenPositionRaw()"); }
	static char ProjectWorldLocationToScreenOrScreenEdgePosition() { return NativeCall<char>(nullptr, "UVictoryCore.ProjectWorldLocationToScreenOrScreenEdgePosition()"); }
	static void AdjustScreenPositionWithScreenDPI(UObject* WorldContextObject, UE::Math::TVector2<double>* ScreenPosition) { NativeCall<void, UObject*, UE::Math::TVector2<double>*>(nullptr, "UVictoryCore.AdjustScreenPositionWithScreenDPI(UObject*,UE::Math::TVector2<double>*)", WorldContextObject, ScreenPosition); }
	static bool IsPointStuckWithinMesh() { return NativeCall<bool>(nullptr, "UVictoryCore.IsPointStuckWithinMesh()"); }
	static bool ServerCheckMeshingOnActor(AActor* OnActor, bool bForceUseActorCenterBounds) { return NativeCall<bool, AActor*, bool>(nullptr, "UVictoryCore.ServerCheckMeshingOnActor(AActor*,bool)", OnActor, bForceUseActorCenterBounds); }
	static void PlayCompanionReactionToPlayers() { NativeCall<void>(nullptr, "UVictoryCore.PlayCompanionReactionToPlayers()"); }
	static void PlayCompanionReactionOnSolePlayer(APrimalCharacter* PlayerWhoGetReaction, FCompanionReactionData* ReactionData, const bool ForcePlayNow, UMaterialInterface* OverrideDialogueIcon, const bool RestrictedEnvironmentalReaction, const int UniqueID) { NativeCall<void, APrimalCharacter*, FCompanionReactionData*, const bool, UMaterialInterface*, const bool, const int>(nullptr, "UVictoryCore.PlayCompanionReactionOnSolePlayer(APrimalCharacter*,FCompanionReactionData*,bool,UMaterialInterface*,bool,int)", PlayerWhoGetReaction, ReactionData, ForcePlayNow, OverrideDialogueIcon, RestrictedEnvironmentalReaction, UniqueID); }
	static void SetMaterialColorizationFromItemColors(UPrimalItem* item, UMaterialInstanceDynamic* dynamicMic) { NativeCall<void, UPrimalItem*, UMaterialInstanceDynamic*>(nullptr, "UVictoryCore.SetMaterialColorizationFromItemColors(UPrimalItem*,UMaterialInstanceDynamic*)", item, dynamicMic); }
	static FString* ConvertIntToStringWithCommas(FString* result, int GivenNumber) { return NativeCall<FString*, FString*, int>(nullptr, "UVictoryCore.ConvertIntToStringWithCommas(FString&,int)", result, GivenNumber); }
	static float GetSimpleMontageDuration(UAnimMontage* GivenMontage, float GivenPlayRate) { return NativeCall<float, UAnimMontage*, float>(nullptr, "UVictoryCore.GetSimpleMontageDuration(UAnimMontage*,float)", GivenMontage, GivenPlayRate); }
	static void PrintMessageInShippingBuild(const FString* msg) { NativeCall<void, const FString*>(nullptr, "UVictoryCore.PrintMessageInShippingBuild(FString&)", msg); }
	static bool IsDinoDuped(UObject* WorldContextObject, const int id1, const int id2) { return NativeCall<bool, UObject*, const int, const int>(nullptr, "UVictoryCore.IsDinoDuped(UObject*,int,int)", WorldContextObject, id1, id2); }
	static bool IsUnderMesh(APrimalCharacter* Character, UE::Math::TVector<double>* CheckSevenHitLocation, bool* bOverlapping, UActorComponent** CheckSevenResult, bool DebugDraw, float DebugDrawSeconds) { return NativeCall<bool, APrimalCharacter*, UE::Math::TVector<double>*, bool*, UActorComponent**, bool, float>(nullptr, "UVictoryCore.IsUnderMesh(APrimalCharacter*,UE::Math::TVector<double>*,bool*,UActorComponent**,bool,float)", Character, CheckSevenHitLocation, bOverlapping, CheckSevenResult, DebugDraw, DebugDrawSeconds); }
	static FString* BPGetPrimaryMapName(FString* result, UObject* WorldContextObject) { return NativeCall<FString*, FString*, UObject*>(nullptr, "UVictoryCore.BPGetPrimaryMapName(FString&,UObject*)", result, WorldContextObject); }
	static FString* SimpleReplaceUnicodeWithSupportedAlternatives(FString* result, const FString* OriginalString) { return NativeCall<FString*, FString*, const FString*>(nullptr, "UVictoryCore.SimpleReplaceUnicodeWithSupportedAlternatives(FString&,FString&)", result, OriginalString); }
	static AActor* SpawnSaddleAttachedStructure() { return NativeCall<AActor*>(nullptr, "UVictoryCore.SpawnSaddleAttachedStructure()"); }
	static void DisableGCM(AActor* targetActor) { NativeCall<void, AActor*>(nullptr, "UVictoryCore.DisableGCM(AActor*)", targetActor); }
	static TArray<FString, TSizedDefaultAllocator<32> >* ChunkFStringIntoArray() { return NativeCall<TArray<FString, TSizedDefaultAllocator<32> >*>(nullptr, "UVictoryCore.ChunkFStringIntoArray()"); }
	static bool IsBrainControllingDinoAttached(APrimalCharacter* character) { return NativeCall<bool, APrimalCharacter*>(nullptr, "UVictoryCore.IsBrainControllingDinoAttached(APrimalCharacter*)", character); }
	static long double GetMissionNetworkStartTime(UObject* WorldContextObject, FName MissionTag) { return NativeCall<long double, UObject*, FName>(nullptr, "UVictoryCore.GetMissionNetworkStartTime(UObject*,FName)", WorldContextObject, MissionTag); }
	static TArray<FName, TSizedDefaultAllocator<32> >* GetLoadedStreamingLevelNames(TArray<FName, TSizedDefaultAllocator<32> >* result) { return NativeCall<TArray<FName, TSizedDefaultAllocator<32> >*, TArray<FName, TSizedDefaultAllocator<32> >*>(nullptr, "UVictoryCore.GetLoadedStreamingLevelNames(TArray<FName,TSizedDefaultAllocator<32>>*)", result); }
	static void BlockTillAllStreamingRequestsFinished() { NativeCall<void>(nullptr, "UVictoryCore.BlockTillAllStreamingRequestsFinished()"); }
	static AActor* DeferredSpawnAndFireProjectile_Start() { return NativeCall<AActor*>(nullptr, "UVictoryCore.DeferredSpawnAndFireProjectile_Start()"); }
	static void ViewTrailer(bool bAnimatedSeriesTrailer, bool bARK2Trailer) { NativeCall<void, bool, bool>(nullptr, "UVictoryCore.ViewTrailer(bool,bool)", bAnimatedSeriesTrailer, bARK2Trailer); }
	static FString* FuseChunkedFString() { return NativeCall<FString*>(nullptr, "UVictoryCore.FuseChunkedFString()"); }
	static char ClipLineInsideBox() { return NativeCall<char>(nullptr, "UVictoryCore.ClipLineInsideBox()"); }
	static void GetLaunchVelocityAndGravity() { NativeCall<void>(nullptr, "UVictoryCore.GetLaunchVelocityAndGravity()"); }
	static void RecordMeshingMetrics(AActor* ForActor, bool bWasDestoryed) { NativeCall<void, AActor*, bool>(nullptr, "UVictoryCore.RecordMeshingMetrics(AActor*,bool)", ForActor, bWasDestoryed); }
	static void DestroyAllCharactersWithinMissionTileVolumes(UObject* WorldContextObject, bool bOnlyCheckForDeadCharacters, FName ForceOnTileStreamVolumeCustomTag) { NativeCall<void, UObject*, bool, FName>(nullptr, "UVictoryCore.DestroyAllCharactersWithinMissionTileVolumes(UObject*,bool,FName)", WorldContextObject, bOnlyCheckForDeadCharacters, ForceOnTileStreamVolumeCustomTag); }
	static bool IsMissionActiveAnywhere(TSubclassOf<AMissionType> MissionType) { return NativeCall<bool, TSubclassOf<AMissionType>>(nullptr, "UVictoryCore.IsMissionActiveAnywhere(TSubclassOf<AMissionType>)", MissionType); }
	static bool IsMissionTagActiveAnywhere(AShooterPlayerController* FromPC, FName MissionTag) { return NativeCall<bool, AShooterPlayerController*, FName>(nullptr, "UVictoryCore.IsMissionTagActiveAnywhere(AShooterPlayerController*,FName)", FromPC, MissionTag); }
	static FName* GetBlockingMissionTag(FName* result, AShooterPlayerController* FromPC, FName MissionTag) { return NativeCall<FName*, FName*, AShooterPlayerController*, FName>(nullptr, "UVictoryCore.GetBlockingMissionTag(FName*,AShooterPlayerController*,FName)", result, FromPC, MissionTag); }
	static bool TryGetLocalizedString() { return NativeCall<bool>(nullptr, "UVictoryCore.TryGetLocalizedString()"); }
	static void GetAllActorsOfClassSoft() { NativeCall<void>(nullptr, "UVictoryCore.GetAllActorsOfClassSoft()"); }
	static FString* ListDinos(FString* result, UObject* WorldContextObject, const bool TamedOnly, const int TargetingTeamExcluded) { return NativeCall<FString*, FString*, UObject*, const bool, const int>(nullptr, "UVictoryCore.ListDinos(FString&,UObject*,bool,int)", result, WorldContextObject, TamedOnly, TargetingTeamExcluded); }
	static FString* ListDinosNew(FString* result, UObject* WorldContextObject) { return NativeCall<FString*, FString*, UObject*>(nullptr, "UVictoryCore.ListDinosNew(FString&,UObject*)", result, WorldContextObject); }
	static bool EnsureNumericAndCharsEx(FString* text, int maxChars, bool bAllowSpace) { return NativeCall<bool, FString*, int, bool>(nullptr, "UVictoryCore.EnsureNumericAndCharsEx(FString&,int,bool)", text, maxChars, bAllowSpace); }
	static TArray<APrimalDinoCharacter*, TSizedDefaultAllocator<32> >* AttemptToSpawnAWildFollower() { return NativeCall<TArray<APrimalDinoCharacter*, TSizedDefaultAllocator<32> >*>(nullptr, "UVictoryCore.AttemptToSpawnAWildFollower()"); }
	static TArray<APrimalDinoCharacter*, TSizedDefaultAllocator<32> >* SpawnFollowerBasedOnRNG() { return NativeCall<TArray<APrimalDinoCharacter*, TSizedDefaultAllocator<32> >*>(nullptr, "UVictoryCore.SpawnFollowerBasedOnRNG()"); }
	static APrimalDinoCharacter* SpawnFollower() { return NativeCall<APrimalDinoCharacter*>(nullptr, "UVictoryCore.SpawnFollower()"); }
	static FPrimalPlayerCharacterConfigStructReplicated* MakePlayerCharacterConfigStructReplicated() { return NativeCall<FPrimalPlayerCharacterConfigStructReplicated*>(nullptr, "UVictoryCore.MakePlayerCharacterConfigStructReplicated()"); }
	static void BreakPlayerCharacterConfigStructReplicated(const FPrimalPlayerCharacterConfigStructReplicated* FromStruct, bool* bIsFemale, TArray<FLinearColor, TSizedDefaultAllocator<32> >* BodyColors, FString* PlayerCharacterName, TArray<float, TSizedDefaultAllocator<32> >* RawBoneModifiers, int* PlayerSpawnRegionIndex, unsigned __int8* HeadHairIndex, unsigned __int8* FacialHairIndex, float* PercentOfFullHeadHairGrowth, float* PercentOfFullFacialHairGrowth, TArray<unsigned char, TSizedDefaultAllocator<32> >* OverrideHeadHairColor, TArray<unsigned char, TSizedDefaultAllocator<32> >* OverrideFacialHairColor, TArray<unsigned char, TSizedDefaultAllocator<32> >* DynamicMaterialBytes, int PlayerVoiceCollectionIndex, bool* bUsingCustomPlayerVoiceCollection) { NativeCall<void, const FPrimalPlayerCharacterConfigStructReplicated*, bool*, TArray<FLinearColor, TSizedDefaultAllocator<32> >*, FString*, TArray<float, TSizedDefaultAllocator<32> >*, int*, unsigned __int8*, unsigned __int8*, float*, float*, TArray<unsigned char, TSizedDefaultAllocator<32> >*, TArray<unsigned char, TSizedDefaultAllocator<32> >*, TArray<unsigned char, TSizedDefaultAllocator<32> >*, int, bool*>(nullptr, "UVictoryCore.BreakPlayerCharacterConfigStructReplicated(FPrimalPlayerCharacterConfigStructReplicated*,bool*,TArray<FLinearColor,TSizedDefaultAllocator<32>>*,FString&,TArray<float,TSizedDefaultAllocator<32>>*,int*,unsigned__int8*,unsigned__int8*,float*,float*,TArray<unsignedchar,TSizedDefaultAllocator<32>>*,TArray<unsignedchar,TSizedDefaultAllocator<32>>*,TArray<unsignedchar,TSizedDefaultAllocator<32>>*,int,bool*)", FromStruct, bIsFemale, BodyColors, PlayerCharacterName, RawBoneModifiers, PlayerSpawnRegionIndex, HeadHairIndex, FacialHairIndex, PercentOfFullHeadHairGrowth, PercentOfFullFacialHairGrowth, OverrideHeadHairColor, OverrideFacialHairColor, DynamicMaterialBytes, PlayerVoiceCollectionIndex, bUsingCustomPlayerVoiceCollection); }
	static AActor* GetNearestAlliedPlayer() { return NativeCall<AActor*>(nullptr, "UVictoryCore.GetNearestAlliedPlayer()"); }
	static AActor* GetNearestAlliedDinoElsePlayer() { return NativeCall<AActor*>(nullptr, "UVictoryCore.GetNearestAlliedDinoElsePlayer()"); }
	static FKey* GetKeybindByPredicate(FKey* result, FName KeybindName) { return NativeCall<FKey*, FKey*, FName>(nullptr, "UVictoryCore.GetKeybindByPredicate(FKey*,FName)", result, KeybindName); }
	static FText* GetKeybindDisplayName(FText* result, FName Keybind) { return NativeCall<FText*, FText*, FName>(nullptr, "UVictoryCore.GetKeybindDisplayName(FText*,FName)", result, Keybind); }
	static UAnimSequence* GetNearestAnimSequenceFromBlendSpace() { return NativeCall<UAnimSequence*>(nullptr, "UVictoryCore.GetNearestAnimSequenceFromBlendSpace()"); }
	static bool GetAllAnimationSequencesFromMontage(UAnimMontage* InMontage, TArray<UAnimationAsset*, TSizedDefaultAllocator<32> >* AnimationAssets) { return NativeCall<bool, UAnimMontage*, TArray<UAnimationAsset*, TSizedDefaultAllocator<32> >*>(nullptr, "UVictoryCore.GetAllAnimationSequencesFromMontage(UAnimMontage*,TArray<UAnimationAsset*,TSizedDefaultAllocator<32>>*)", InMontage, AnimationAssets); }
	static char GetPreviousTrackedActorLinkedEntry() { return NativeCall<char>(nullptr, "UVictoryCore.GetPreviousTrackedActorLinkedEntry()"); }
	static char GetNextTrackedActorLinkedEntry() { return NativeCall<char>(nullptr, "UVictoryCore.GetNextTrackedActorLinkedEntry()"); }
	static void DoForceStreamComponents(TArray<UMeshComponent*, TSizedDefaultAllocator<32> >* ComponentsArray, bool bIsFirstPerson, bool bForceMaxTexturesOnConsole) { NativeCall<void, TArray<UMeshComponent*, TSizedDefaultAllocator<32> >*, bool, bool>(nullptr, "UVictoryCore.DoForceStreamComponents(TArray<UMeshComponent*,TSizedDefaultAllocator<32>>*,bool,bool)", ComponentsArray, bIsFirstPerson, bForceMaxTexturesOnConsole); }
	static int IsChildOfClassesSoftRefT<class UObject>(TSubclassOf<UObject> childClass, const TArray<TSoftClassPtr<UObject>, TSizedDefaultAllocator<32> >* ParentClassesArray) { return NativeCall<int, TSubclassOf<UObject>, const TArray<TSoftClassPtr<UObject>, TSizedDefaultAllocator<32> >*>(nullptr, "UVictoryCore.IsChildOfClassesSoftRefT<class UObject>(TSubclassOf<UObject>,TArray<TSoftClassPtr<UObject>,TSizedDefaultAllocator<32>>*)", childClass, ParentClassesArray); }
	static _BOOL8 OverlappingActorsTrace() { return NativeCall<_BOOL8>(nullptr, "UVictoryCore.OverlappingActorsTrace()"); }
	static int IsChildOfClassesSoftRefT<class AActor>(TSubclassOf<UObject> childClass, const TArray<TSoftClassPtr<AActor>, TSizedDefaultAllocator<32> >* ParentClassesArray) { return NativeCall<int, TSubclassOf<UObject>, const TArray<TSoftClassPtr<AActor>, TSizedDefaultAllocator<32> >*>(nullptr, "UVictoryCore.IsChildOfClassesSoftRefT<class AActor>(TSubclassOf<UObject>,TArray<TSoftClassPtr<AActor>,TSizedDefaultAllocator<32>>*)", childClass, ParentClassesArray); }
	static int IsChildOfClassesT<class UPrimalItem>(TSubclassOf<UObject> childClass, const TArray<TSubclassOf<UPrimalItem>, TSizedDefaultAllocator<32> >* ParentClassesArray) { return NativeCall<int, TSubclassOf<UObject>, const TArray<TSubclassOf<UPrimalItem>, TSizedDefaultAllocator<32> >*>(nullptr, "UVictoryCore.IsChildOfClassesT<class UPrimalItem>(TSubclassOf<UObject>,TArray<TSubclassOf<UPrimalItem>,TSizedDefaultAllocator<32>>*)", childClass, ParentClassesArray); }
	static int IsChildOfClassesSoftRefT<class APrimalStructure>(TSubclassOf<UObject> childClass, const TArray<TSoftClassPtr<APrimalStructure>, TSizedDefaultAllocator<32> >* ParentClassesArray) { return NativeCall<int, TSubclassOf<UObject>, const TArray<TSoftClassPtr<APrimalStructure>, TSizedDefaultAllocator<32> >*>(nullptr, "UVictoryCore.IsChildOfClassesSoftRefT<class APrimalStructure>(TSubclassOf<UObject>,TArray<TSoftClassPtr<APrimalStructure>,TSizedDefaultAllocator<32>>*)", childClass, ParentClassesArray); }
	static int IsChildOfClassesT<class APrimalStructure>(TSubclassOf<UObject> childClass, const TArray<TSubclassOf<APrimalStructure>, TSizedDefaultAllocator<32> >* ParentClassesArray) { return NativeCall<int, TSubclassOf<UObject>, const TArray<TSubclassOf<APrimalStructure>, TSizedDefaultAllocator<32> >*>(nullptr, "UVictoryCore.IsChildOfClassesT<class APrimalStructure>(TSubclassOf<UObject>,TArray<TSubclassOf<APrimalStructure>,TSizedDefaultAllocator<32>>*)", childClass, ParentClassesArray); }
};
